{"version":3,"sources":["webpack://Telegraph/webpack/bootstrap","webpack://Telegraph/./src/modules/state.js","webpack://Telegraph/./src/utils/dom.js","webpack://Telegraph/./src/utils/event.js","webpack://Telegraph/./src/utils/debounce.js","webpack://Telegraph/./src/modules/path.js","webpack://Telegraph/./src/modules/bar.js","webpack://Telegraph/./src/modules/area.js","webpack://Telegraph/./src/utils/numbers.js","webpack://Telegraph/./src/utils/log.js","webpack://Telegraph/./src/modules/graph.js","webpack://Telegraph/./src/modules/minimap.js","webpack://Telegraph/./src/modules/tooltip.js","webpack://Telegraph/./src/modules/pointer.js","webpack://Telegraph/./src/modules/chart.js","webpack://Telegraph/./src/modules/legend.js","webpack://Telegraph/./src/modules/header.js","webpack://Telegraph/./src/telegraph.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACe;AACf;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,C;;ACzTA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA,YAAY;AACZ;AACO,8DAA8D;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,C;;AC1DA;AACA;AACA,WAAW,sBAAsB;AACjC;AACO;AACP;AACA;AACA;;AAEA;AACA,C;;ACVA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;ACpBoC;;AAEpC;AACA;AACA;AACe,MAAM,SAAI;AACzB,eAAe,yEAAyE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,IAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,0BAA0B,UAAU,GAAG,UAAU;AACjD;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB,GAAG,UAAU;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAI;AAC5C;;AAEA;AACA,+BAA+B,SAAI;AACnC;AACA,C;;AC7FoC;;AAEpC;AACA;AACA;AACe,MAAM,OAAG;AACxB,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,IAAQ;AAC3B,uCAAuC,OAAG;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,IAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAG;AACrC;AACA,C;;AC3FoC;;AAEpC;AACA;AACA;AACe,MAAM,SAAI;AACzB,eAAe,gCAAgC;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,IAAQ;AACvB;AACA;AACA,KAAK;;AAEL,uBAAuB,SAAI;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,4BAA4B,EAAE,GAAG,qCAAqC;AACtE;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,GAAG,mBAAmB;AACrE;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;;AAEA,qCAAqC,EAAE,GAAG,mBAAmB;AAC7D;;AAEA;AACA,oBAAoB,IAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,GAAG,kBAAkB,KAAK,kBAAkB;AAC3F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,SAAI;AACnC;AACA,C;;ACxIO;AACP;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP,6CAA6C,EAAE;AAC/C;;;ACtDA;;;AAGe;AACf;AACA;;AAEA;;AAEA;AACA,mBAAmB,IAAI,GAAG,yCAAyC;AACnE,IAAI;;AAEJ;AACA,C;;ACdoC;AACV;AACF;AACE;AACkB;;AAEV;;;AAGlC;AACA;AACA;AACe,MAAM,WAAK;AAC1B;AACA,aAAa,UAAU;AACvB;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA,gBAAgB,cAAc,KAAK;AACnC,kBAAkB,IAAQ;AAC1B,mBAAmB,IAAQ;AAC3B,mBAAmB,IAAQ;;AAE3B,uCAAuC,WAAK;AAC5C,uCAAuC,WAAK;AAC5C;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAI;AACrB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,KAAK;;AAEL,4BAA4B,0BAA0B;AACtD;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,iBAAiB,OAAG;AACpB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA,4BAA4B,0BAA0B;AACtD;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,qCAAqC;AACrC,4BAA4B,WAAW;;;AAGvC;AACA;AACA,OAAO;;;;AAIP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,SAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,SAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,6CAA6C,2BAA2B,SAAS,QAAQ;AACzF;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;;AAGA,aAAa,UAAkB;;;AAG/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,eAAe,eAAe,MAAM;;AAEnF,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,UAAU,eAAe,MAAM;AAC5E,yDAAyD,UAAU,iBAAiB,MAAM;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sDAAsD,eAAe;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,4BAA4B,0BAA0B;AACtD;;AAEA;AACA;AACA,OAAO;;AAEP,+CAA+C,eAAe;AAC9D;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sDAAsD,eAAe;AACrE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,4BAA4B,0BAA0B;AACtD;;AAEA;AACA;AACA,OAAO;;AAEP,+CAA+C,eAAe;AAC9D;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;AC/nBuC;AACI;AACC;AACb;AACG;;;AAGlC;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,eAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAK;AAC1B;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,eAAO;AAChD,0BAA0B,IAAQ,QAAQ,eAAO;AACjD,4BAA4B,IAAQ,QAAQ,eAAO;AACnD,2BAA2B,IAAQ,QAAQ,eAAO;AAClD,gCAAgC,IAAQ,QAAQ,eAAO;AACvD,iCAAiC,IAAQ,QAAQ,eAAO;;AAExD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;AAC1C;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,WAAW,OAAO;;AAElB;;AAEA,mDAAmD,eAAO,oBAAoB;AAC9E,oDAAoD,eAAO,qBAAqB;;AAEhF;AACA,sBAAsB,QAAc;;AAEpC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA,gBAAgB,QAAc;;AAE9B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,OAAO;AACpB;AACA;AACA,gBAAgB,QAAc;AAC9B;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,C;;ACjhBuC;AACK;;AAE7B,MAAM,eAAO;AAC5B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,IAAQ,QAAQ,eAAO;AAChD,uBAAuB,IAAQ,QAAQ,eAAO;AAC9C,wBAAwB,IAAQ,QAAQ,eAAO;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,eAAO;AAC5C;;AAEA;AACA,wCAAwC,eAAO;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA,uCAAuC,KAAK;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B,GAAG;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,8CAA8C,eAAe;AAC7D;AACA;;;AAGA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA,SAAS;;AAET;AACA;AACA;AACA,OAAO;;AAEP,KAAK;AACL,0BAA0B,YAAY;AACtC;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,IAAQ,QAAQ,eAAO;AACxC,oBAAoB,IAAQ;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,IAAQ;;AAE9B;;AAEA;AACA;;AAEA,kBAAkB,IAAQ,SAAS,eAAO;;AAE1C;;AAEA;AACA;;AAEA;;AAEA,0BAA0B,SAAiB;;AAE3C;AACA,MAAM,cAAkB;AACxB,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAQ;AACvB,gBAAgB,IAAQ;;AAExB;;;AAGA;AACA;AACA;;AAEA,qBAAqB,cAAc,IAAI,IAAI;;;AAG3C,IAAI,cAAkB,UAAU,cAAc,IAAI,IAAI;AACtD;AACA;AACA,C;;ACnNoC;;AAEpC;AACA;AACA;AACe,MAAM,eAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,IAAQ,QAAQ,eAAO;AAChD;AACA;;AAEA;AACA,qCAAqC,eAAO;AAC5C;;AAEA;AACA,wCAAwC,eAAO;AAC/C;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;;AAEA;AACA;AACA,2CAA2C,eAAO;AAClD;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B,GAAG;AAC7C;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B,qBAAqB,IAAQ,QAAQ,eAAO;;AAE5C;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,cAAc;AACd;AACA,WAAW,MAAM;;AAEjB,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;;AAEA,gCAAgC,MAAM;AACtC,4CAA4C,MAAM;AAClD,KAAK;;AAEL;AACA,C;;ACnFuC;AACR;AACC;AACA;AACW;;AAET;AACU;AACpB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,WAAK;AAC1B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,eAAO;AAC9B,uBAAuB,eAAO;AAC9B,qBAAqB,WAAK;AAC1B;AACA,KAAK;;AAEL;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,YAAY,sBAAsB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,WAAK;AAC9C,0BAA0B,IAAQ,QAAQ,WAAK;AAC/C;;AAEA;AACA;AACA;;AAEA,qCAAqC,WAAK;;AAE1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,IAAQ,QAAQ,WAAK;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,IAAQ,SAAS,WAAK;AACxC,0BAA0B,QAAgB;;AAE1C;;AAEA;AACA,4BAA4B,WAAK;AACjC,KAAK;AACL,4BAA4B,WAAK;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAQ,QAAQ,WAAK;AAC7C;AACA,MAAM,YAAgB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,WAAK;AAChC,OAAO;AACP;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4BAA4B,WAAK;AACjC,6BAA6B,OAAO;;AAEpC;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C,OAAO;;AAElD;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,IAAQ;AAC3B;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,wBAAwB,IAAQ;;AAEhC;;AAEA,IAAI,WAAe;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;;AAE1C;AACA;AACA,KAAK,qBAAqB,gBAAgB;AAC1C;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,YAAY,QAAc;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,KAAK;AAC3D,4BAA4B,WAAK;AACjC,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,IAAQ;AAClC,8CAA8C,WAAK;;;AAGnD,6BAA6B,IAAQ;AACrC,iDAAiD,WAAK;AACtD,8BAA8B,IAAQ;AACtC,kDAAkD,WAAK;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,C;;AC3zBuC;;AAExB,MAAM,aAAM;AAC3B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,aAAM;;AAE/C;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;;AAEL,yBAAyB,YAAY;AACrC,iBAAiB,IAAQ,SAAS,aAAM,WAAW,aAAM;AACzD,mBAAmB,IAAQ,SAAS,aAAM;;AAE1C;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,8CAA8C,aAAM;AACpD;AACA;;AAEA;AACA;AACA,SAAS;AACT,2CAA2C,aAAM;AACjD;AACA;;AAEA,2CAA2C,aAAM;AACjD;AACA,gDAAgD,aAAM;AACtD,WAAW;;AAEX;AACA;AACA;AACA,KAAK;;AAEL;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA,+CAA+C,aAAM;AACrD,uCAAuC,aAAM;AAC7C;AACA;;AAEA,uCAAuC,aAAM;AAC7C;AACA,4CAA4C,aAAM;AAClD,OAAO;AACP,KAAK;AACL;AACA,yCAAyC,aAAM;AAC/C;AACA,8CAA8C,aAAM;AACpD,SAAS;;AAET;AACA;;AAEA,0CAA0C,aAAM;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AC1KoC;;AAErB,MAAM,aAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,IAAQ,QAAQ,aAAM;AAC/C,uBAAuB,IAAQ,QAAQ,aAAM;AAC7C,uBAAuB,IAAQ,QAAQ,aAAM;;AAE7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP,sCAAsC,SAAS,KAAK,UAAU;;AAE9D,KAAK;AACL;AACA,C;;AClDA;AAAoC;AACO;AACJ;AACE;AACA;;AAEzC;AACA,aAAa,OAAO;AACpB;;AAEe,MAAM,mBAAS;AAC9B;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,eAAe,qCAAqC;AACpD;;AAEA;AACA;AACA;AACA,qBAAqB,KAAK;;AAE1B;AACA;AACA;AACA,uBAAuB,eAAO;;AAE9B;AACA;AACA;AACA,qBAAqB,WAAK;;AAE1B;AACA;AACA;AACA,sBAAsB,aAAM;;AAE5B;AACA;AACA;AACA,sBAAsB,aAAM;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAS;AAC1C;AACA,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * This class stores the sate of application\n * @todo add cache to all getters\n */\nexport default class State {\n  /**\n   * @param {string} chartsData - input data in csv format\n   * @param {string[]} colors - colors list for each line\n   * @param {string[]} titles - titles list for each line\n   * @param {string} type - graph type - line, area, bar\n   */\n  constructor(chartsData, colors, titles, type){\n    const lines = chartsData.split('\\n');\n\n    this.columns = [];\n    this.dates = [];\n    this.type = type;\n\n    lines.forEach((line) => {\n      let [date, ...values] = line.split(',');\n\n      values.forEach((val, index) => {\n        val = parseInt(val, 10);\n\n        if (this.columns[index]){\n          this.columns[index].push(val);\n        } else {\n          this.columns[index] = [val];\n        }\n      });\n\n      this.dates.push(date);\n    });\n\n    this.colors = colors;\n    this.names = titles;\n    this.isYScaled = false;\n\n    /**\n     * Cache\n     */\n    this._cache = {\n      /**\n       * @todo maybe array copying worst than slice\n       */\n      getLinePoints: {},\n      dates: this.columns[0].slice(1),\n      daysCount: this.columns[0].slice(1).length\n    };\n\n    this._recalculatedPoints = [];\n  }\n\n  /**\n   * Column with dates is 0-index column, so shift it\n   * First element in arrays is column name (\"x\") so slice it\n   * @return {number[]} - array of dates in milliseconds\n   */\n  // get dates(){\n  //   return this._cache.dates;\n  // }\n\n  /**\n   * Return available line names\n   * @return {string[]} - array of graph names\n   */\n  get linesAvailable(){\n    return Object.keys(this.names);\n  }\n\n  /**\n   * Returns numbers of days at the input data\n   * @return {number}\n   */\n  get daysCount(){\n    return this._cache.daysCount;\n  }\n\n  /**\n   * Returns values of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {number[]}\n   */\n  getLinePoints(lineName){\n    if (this._cache.getLinePoints[lineName]){\n      return this._cache.getLinePoints[lineName];\n    }\n\n    this._cache.getLinePoints[lineName] = this.getColumnByName(lineName);\n\n\n    return this._cache.getLinePoints[lineName];\n  }\n\n  /**\n   * Return column by name\n   * @param {string} name - \"y0\", \"y1\" etc\n   * @return {array}\n   */\n  getColumnByName(name){\n    return this.columns[name];\n  }\n\n  /**\n   * Return N points from passed position\n   * @param {string} lineName - \"y0\", \"y1\", ...etc\n   * @param {number} from - start position\n   * @param {number} count - how many items requested\n   * @return {number[]}\n   */\n  getPointsSlice(lineName, from, count){\n    return this.getLinePoints(lineName).slice(from, from + count);\n  }\n\n  /**\n   * Returns color of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {string} - hex color like \"#333333\"\n   */\n  getLineColor(lineName){\n    return this.colors[lineName];\n  }\n\n  /**\n   * Returns chart type by name\n   * @param {string} chartName - \"y0\", \"y1\" etc\n   * @return {string} - \"line\", \"bar\", \"area\"\n   */\n  getChartType(chartName){\n    return this.types[chartName];\n  }\n\n  /**\n   * Detect type of charts\n   * @return {string}\n   */\n  getCommonChartsType(){\n    return this.type;\n  }\n\n  /**\n   * Return value of same point of previous chart\n   * @param currentChartNumber\n   * @param pointIndex\n   */\n  getPrevChartValueForPoint(currentChartNumber, pointIndex){\n    let prevChartKey = this.linesAvailable[currentChartNumber - 1];\n    return this.getLinePoints(prevChartKey)[pointIndex];\n  }\n\n  /**\n   * Return a stack value for each point\n   */\n  getStacks(){\n    if (this._cache.stacks){\n      return this._cache.stacks;\n    }\n\n    let from = 0;\n    let to = this.daysCount;\n    let stacks = [];\n\n    for (let pointIndex = from; pointIndex < to; pointIndex++){\n      let stackValue = this.getStackForPoint(pointIndex);\n\n      stacks.push(stackValue);\n    }\n\n    this._cache.stacks = stacks;\n\n    return this._cache.stacks;\n  }\n\n  /**\n   * Return accumulated stack value for point\n   * @param {number} pointIndex\n   * @param {string[]} skipLines - line numbers to skip (it may be hidden)\n   * @return {number}\n   */\n  getStackForPoint(pointIndex, skipLines = []){\n    let stackValue = 0;\n\n    this.linesAvailable.forEach(line => {\n      if (skipLines.includes(line)){\n        return;\n      }\n\n      stackValue += this.getLinePoints(line)[pointIndex];\n    });\n\n    return stackValue;\n  }\n\n  /**\n   *\n   * @param from\n   * @param to\n   * @param {string[]} skipLines - line numbers to skip (it may be hidden)\n   * @return {number}\n   */\n  getMaximumAccumulatedByColumns(from = 0, to = this.daysCount, skipLines = []){\n    let max = 0;\n\n    for (let pointIndex = from; pointIndex < to; pointIndex++){\n      let stackValue = this.getStackForPoint(pointIndex, skipLines);\n\n      if (max < stackValue){\n        max = stackValue;\n      }\n    }\n\n    return max;\n  }\n\n  /**\n   * Returns chart type by name\n   * @param {string} chartName - \"y0\", \"y1\" etc\n   * @return {string} - \"line\", \"bar\", \"area\"\n   */\n  getOhterTypes(chartName){\n    return Object.keys(this.types).filter(type => type !== chartName);\n  }\n\n  /**\n   * Return maximum value from all charts\n   * @return {number}\n   */\n  get max(){\n    const maxPerLines = this.linesAvailable.map( name => {\n      return Math.max(...this.getLinePoints(name));\n    });\n\n    return Math.max(...maxPerLines);\n  }\n\n  /**\n   * Return maximum value for passed line\n   * @return {number}\n   */\n  maxForLine(name){\n    return Math.max(...this.getLinePoints(name));\n  }\n\n  /**\n   * Return minimum value from all charts\n   * @return {number}\n   */\n  get min(){\n    const minPerLines = this.linesAvailable.map( name => {\n      return Math.min(...this.getLinePoints(name));\n    });\n\n    return Math.min(...minPerLines);\n  }\n\n  /**\n   * Return minimum value for passed line\n   * @return {number}\n   */\n  minForLine(name){\n    return Math.min(...this.getLinePoints(name));\n  }\n\n  /**\n   * Return max value for line with start point and next N visible\n   */\n  getMaxForLineSliced(line, leftPointIndex, pointsVisible){\n    return Math.max(...this.getPointsSlice(line, leftPointIndex, pointsVisible));\n  }\n\n  /**\n   * Return min value for line with start point and next N visible\n   */\n  getMinForLineSliced(line, leftPointIndex, pointsVisible){\n    return Math.min(...this.getPointsSlice(line, leftPointIndex, pointsVisible));\n  }\n\n  /**\n   * Array of available colors\n   * @return {string[]}\n   */\n  get colorsList(){\n    return Object.entries(this.colors).map(([name, value]) => value);\n  }\n\n  /**\n   * Array of available chart names\n   * @return {string[]}\n   */\n  get namesList(){\n    return Object.entries(this.names).map(([name, value]) => value);\n  }\n\n  /**\n   * Stores previously calculated values to prevent do the same both for chart and for mini map\n   * @type {Array}\n   */\n  saveRecalculatedValues(values){\n    this._recalculatedPoints.push(values);\n  }\n\n  /**\n   * Dealloc used values\n   * @type {Array}\n   */\n  clearRecalculatedValues(){\n    this._recalculatedPoints = [];\n  }\n\n  get recalculatedValues(){\n    return this._recalculatedPoints;\n  }\n\n}","/**\n * Create HTML element\n * @param {string} tagName - HTML element tag name\n * @param {string[]|string} classNames - array of CSS classes\n * @param attributes - any attributes\n * @return {HTMLElement}\n */\nexport function make(tagName, classNames = undefined, attributes = {}) {\n  const svgNamespace = 'http://www.w3.org/2000/svg';\n  const svgElements = ['svg', 'path', 'rect', 'circle', 'text', 'g', 'animate'];\n  const isSvg = svgElements.includes(tagName);\n  const el = !isSvg ? document.createElement(tagName) : document.createElementNS(svgNamespace, tagName);\n\n  if (Array.isArray(classNames) && classNames.length) {\n    el.classList.add(...classNames);\n  } else if (classNames) {\n    el.className = classNames;\n  }\n\n  if (attributes && Object.keys(attributes).length) {\n    for (let attrName in attributes) {\n      if (attributes.hasOwnProperty(attrName)) {\n        el.setAttribute(attrName, attributes[attrName]);\n      }\n    }\n  }\n\n  return el;\n}\n\n/**\n * Inserts one element after another\n */\nexport function insertAfter(target, element) {\n  target.parentNode.insertBefore(element, target.nextSibling);\n}\n\n/**\n * Insert one element before another\n */\nexport function insertBefore(target, element) {\n  target.parentNode.insertBefore(element, target);\n}\n\nexport function animateCounter(holder, val, prevVal, animateType = 'default'){\n  let prev = make('span', ['counter-prev', animateType]);\n  let cur = make('span', ['counter-cur', animateType]);\n\n  holder.style.width = val.length * 7 + 'px';\n\n  prev.textContent = prevVal;\n  cur.textContent = val;\n\n  holder.innerHTML = '';\n  holder.appendChild(prev);\n\n  holder.appendChild(cur);\n\n}","/**\n * Return pageX for passed Event\n * @param {MouseEvent|TouchEvent} event\n */\nexport function getPageX(event) {\n  if (event.touches){\n    return event.touches[0].pageX;\n  }\n\n  return event.pageX;\n}","/**\n * Invoke a function with debounce\n * @param {function} func - callback\n * @param {number} wait - how many second should be awaited before calling a callback\n * @param {boolean} immediate - pass true to call immediately\n * @return {Function}\n */\nexport default function debounce(func, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};","import * as Dom from \"../utils/dom\";\n\n/**\n * Helper for creating an SVG path\n */\nexport default class Path {\n  constructor({canvasHeight, zeroShifting, color, kY, stroke, stepX, max, min, isScaled}){\n    this.canvasHeight = canvasHeight;\n    this.zeroShifting = zeroShifting;\n    this.kY = kY;\n    this.stepX = stepX;\n    this.prevX = 0;\n    this.max = max;\n    this.min = min;\n\n    // here will be stored current minimum value for 2-y axis charts\n    this.currentMinimum = 0;\n\n    this.path = Dom.make('path', null, {\n      'stroke-width' : stroke,\n      stroke : color,\n      fill : 'transparent',\n      'stroke-linecap' : 'round',\n      'stroke-linejoin' : 'round',\n      'vector-effect': 'non-scaling-stroke',\n    });\n\n    if (isScaled){\n      this.path.classList.add('scaled');\n    }\n\n    this.pathData = '';\n  }\n\n  /**\n   * CSS classes map\n   * @return {{graphHidden: string}}\n   */\n  static get CSS(){\n    return {\n      graphHidden: 'tg-graph--hidden',\n    }\n  }\n\n  /**\n   * Compute Y value with scaling\n   */\n  y(val){\n    return Math.round(this.canvasHeight - val * this.kY + this.zeroShifting);\n  }\n\n  /**\n   * Compute X value with scaling\n   */\n  x(val){\n    return val;\n  }\n\n  /**\n   * Go to passed coords\n   * @param {number} x\n   * @param {number} y\n   */\n  moveTo(x, y){\n    this.pathData += `M ${this.x(x)} ${this.y(y)}`;\n  }\n\n  /**\n   * Continue line to the next value\n   * @param {number} y\n   */\n  stepTo(y, skipStep){\n    if (!skipStep){\n      this.prevX = this.prevX + this.stepX;\n    }\n    this.pathData += ` L ${this.x(this.prevX)} ${this.y(y)}`;\n  }\n\n  /**\n   * Append a line\n   */\n  render(){\n    this.path.setAttribute('d', this.pathData);\n    return this.path;\n  }\n\n  get isHidden(){\n    return this.path.classList.contains(Path.CSS.graphHidden);\n  }\n\n  toggleVisibility(status){\n    this.path.classList.toggle(Path.CSS.graphHidden, status);\n  }\n}","import * as Dom from \"../utils/dom\";\n\n/**\n * Helper for creating an Bar charts\n */\nexport default class Bar {\n  constructor({canvasHeight, kY, stepX, key}){\n    this.canvasHeight = canvasHeight;\n    this.kY = kY;\n    this.key = key;\n\n    this.prevX = 0;\n    this.stepX = stepX;\n\n    this.wrapper = Dom.make('g');\n    this.wrapper.setAttribute('class', Bar.CSS.wrapper);\n    this.wrapper.setAttribute('vector-effect', 'non-scaling-stroke');\n    this.hidden = false;\n  }\n\n  getAll(){\n    return this.wrapper;\n  }\n\n  /**\n   * CSS classes map\n   * @return {{graphHidden: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-bar',\n      graphHidden: 'tg-bar--hidden',\n    }\n  }\n\n  /**\n   * Compute Y value with scaling\n   */\n  y(val){\n    return this.canvasHeight - val * this.kY;\n  }\n\n  /**\n   * Compute X value with scaling\n   */\n  x(val){\n    return val;\n  }\n\n  /**\n   * Continue line to the next value\n   * @param {number} y\n   */\n  add(y, stackValue, prevValue, color){\n    this.prevX = this.prevX + this.stepX;\n    let stackScaled = stackValue * this.kY;\n    let heightPrev = prevValue * this.kY;\n    let height = stackScaled - heightPrev;\n\n    const bar = Dom.make('rect');\n    bar.setAttribute('width', this.stepX);\n    bar.setAttribute('height', height);\n    bar.setAttribute('x', this.prevX);\n    bar.setAttribute('y', this.y(stackValue - prevValue));\n    bar.setAttribute('fill', color);\n    // bar.setAttribute('stroke', color);\n    // bar.setAttribute('opacity', 0.6);\n\n\n    this.wrapper.appendChild(bar);\n  }\n\n  move(index, newStack, prevValue) {\n    let bar = this.wrapper.children[index];\n    let stackScaled = newStack * this.kY;\n    let heightPrev = prevValue * this.kY;\n    let height = stackScaled - heightPrev;\n\n    bar.setAttribute('height', height);\n    bar.setAttribute('y', this.y(newStack - prevValue));\n  }\n\n\n  get isHidden(){\n    return this.hidden;\n  }\n\n  toggleVisibility(status){\n    this.hidden = !this.hidden;\n    this.wrapper.classList.toggle(Bar.CSS.graphHidden, status);\n  }\n}","import * as Dom from \"../utils/dom\";\n\n/**\n * Helper for creating an Bar charts\n */\nexport default class Area {\n  constructor({canvasHeight, stepX, key, color}){\n    this.canvasHeight = canvasHeight;\n    this.key = key;\n    this.color = color;\n\n    this.prevX = 0;\n    this.stepX = stepX;\n    this.hidden = false;\n\n\n    this.path = this.createPath();\n    this.morphing = undefined;\n\n    this.pathData = [];\n  }\n\n  createPath(){\n    let path = Dom.make('path', null, {\n      fill : this.color,\n      'vector-effect': 'non-scaling-stroke',\n    });\n\n    path.classList.add(Area.CSS.path);\n\n    return path;\n  }\n\n  getAll(){\n    return this.path;\n  }\n\n  /**\n   * CSS classes map\n   * @return {{graphHidden: string}}\n   */\n  static get CSS(){\n    return {\n      path: 'tg-area',\n      graphHidden: 'tg-area--hidden',\n    }\n  }\n\n  /**\n   * Compute Y value with scaling\n   */\n  y(val){\n    return this.canvasHeight - val;\n  }\n\n  /**\n   * Compute X value with scaling\n   */\n  x(val){\n    return val;\n  }\n\n  percentToValue(per){\n    return this.canvasHeight / 100 * per;\n  }\n\n  valueToPercent(val, total){\n    return 100 / total * val;\n  }\n\n  /**\n   * Go to passed coords\n   * @param {number} x\n   * @param {number} y\n   */\n  moveTo(x, y, total = 0){\n    let valueInPercents = total ? this.valueToPercent(y, total) : y;\n    this.pathData.push(`M ${x} ${this.percentToValue(valueInPercents)}`);\n  }\n\n  /**\n   * Continue line to the next value\n   * @param {number} total - this value is 100% for all charts\n   */\n  stepTo(total, prev, skip = false){\n    let prevPercents = 100 / total * prev;\n    let percentage = this.percentToValue(100 - prevPercents);\n    // console.log('current per %o | 100% is %o | prev percents is %o | -->', curPercents, total, prevPercents, percentage);\n    if (!skip) {\n      this.prevX = this.prevX + this.stepX;\n    }\n    this.pathData.push(`L ${this.x(this.prevX)} ${this.y(percentage)}`);\n  }\n\n  /**\n   * Recalculate Y coordinate\n   * @param {number} y\n   * @param {number} total - this value is 100% for all charts\n   */\n  move(index, total, prev){\n    let pointToChange = this.pathData[index + 1]; // +1 to skip M value\n    let [l, x, y] = pointToChange.trim().split(' ');\n\n    let prevPercents = 100 / total * prev;\n    let percentage = this.percentToValue(100 - prevPercents);\n\n    this.pathData[index + 1] = ` L ${x} ${this.y(percentage)}`;\n  }\n\n  update(){\n    this.morphing = Dom.make('animate');\n    this.morphing.setAttribute('attributeName', 'd');\n    this.morphing.setAttribute('attributeType', 'XML');\n    this.morphing.setAttribute('dur', '170ms');\n    this.morphing.setAttribute('fill', 'freeze');\n    this.morphing.setAttribute('to', this.pathData.join(' '));\n    this.path.appendChild(this.morphing);\n    this.morphing.beginElement();\n  }\n\n  /**\n   * Append a line\n   */\n  finish(){\n    this.pathData.push(`L ${this.x(this.prevX)} ${this.canvasHeight} 0 ${this.canvasHeight} 0 0`);\n    this.path.setAttribute('d', this.pathData.join(' '));\n  }\n\n  get isHidden(){\n    return this.hidden;\n  }\n\n  toggleVisibility(status){\n    this.hidden = !this.hidden;\n    this.path.classList.toggle(Area.CSS.graphHidden, status);\n  }\n}","export function round(number) {\n  let zeros = Math.log10(number) >> 0;\n  let rounding = Math.pow(10, zeros);\n\n  return Math.round(number / rounding) * rounding;\n}\n\nexport function roundToMin(number, maxSlicing) {\n  let zeros = Math.log10(number) >> 0;\n  let rounding = Math.pow(10, zeros);\n  let result = Math.floor(number / rounding) * rounding;\n\n  // console.log(number, ' -> zeros', zeros, 'r' , rounding, maxSlicing);\n\n  if (number - result > maxSlicing){\n    // let old  =result;\n    rounding = Math.pow(10, zeros - 1);\n    result = Math.floor(number / rounding) * rounding;\n    // console.warn('descreasing', old, result)\n  }\n\n  return result;\n}\n\nexport function beautify(number) {\n  if (number < 1000) {\n    return number\n  } else if (number < 10000){\n      let thousands = Math.floor(number / 1000);\n      let left = number - thousands * 1000;\n\n      if (left === 0){\n        return thousands + ' 000';\n      } else if (left >= 100){\n        return thousands + ' ' + left;\n      } else if (left > 10) {\n        return thousands + ' 0' + left;\n      } else {\n        return thousands + ' 0' + left;\n      }\n  } else if (number < 1000000) {\n      return Math.floor(number / 1000) + 'k';\n  } else {\n    return Math.floor(number / 1000000) + 'M';\n  }\n}\n\n/**\n * 1000 -> 1 000\n * @param {number} number\n * @return {string}\n */\nexport function addSpaces(number) {\n  return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ');\n}\n","let prevValues = {};\n\n\nexport default function log(obj){\n  let el = document.getElementById('log');\n   Object.assign(prevValues, obj);\n\n   let content = '';\n\n   Object.entries(prevValues).forEach(([key, value]) => {\n     content += `${key} ${!isNaN(value) ? value.toFixed(3) : value}   `\n   })\n\n  el.innerHTML = content;\n}","import * as Dom from '../utils/dom';\nimport Path from './path';\nimport Bar from './bar';\nimport Area from './area';\nimport * as Numbers from \"../utils/numbers\";\n\nimport log from '../utils/log.js';\n\n\n/**\n * Working with svg paths for charts\n */\nexport default class Graph {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules, {stroke}){\n    /**\n     * Width of date label is used for default stepX value in 1:1 scale\n     * @type {number}\n     */\n    const dateLabelWidth = 45;\n\n    this.modules = modules;\n    this.state = modules.state;\n    this.type = this.state.getCommonChartsType();\n\n    /**\n     * @todo move to this.nodes\n     */\n    this.canvas = undefined;\n\n    /**\n     * Transformations on OY\n     */\n    this.oyGroup = undefined;\n\n    /**\n     * Transformations on OX\n     */\n    this.oxGroup = undefined;\n\n    this.stepX = dateLabelWidth;\n    this.stepY = 10;\n    this.strokeWidth = stroke;\n    this.initialWidth = undefined;\n    this.maxPoint = 0;//\n    this.minPoint = 0;\n\n    /**\n     * [ canvas height / (Max - Min) ]\n     * Ratio from 1:1 scale to fit min (on zero-axis) and max (on top Y axis)\n     */\n    this.kY = 1;\n\n    /**\n     * [ min point * kY ]\n     * On how much we should move down chart to make min-point hit zero-axis\n     */\n    this.zeroShifting = 0;\n\n    /**\n     * What point is currently fit zero-axis;\n     */\n    this.currentMinimum = 0;\n\n    /**\n     * [ new kY / original kY ]\n     * How much the original kY is changed to fit new min & max points\n     */\n    this.oyScaling = 1;\n\n    /**\n     * [ original shift / new shift ]\n     * How much the original zero axis shifting is changed to fit new min & max points\n     */\n    this.zeroShiftingScaling = 1;\n\n\n\n    /**\n     * List of drawn charts\n     * @type {object} name -> Path\n     */\n    this.charts = {};\n\n    /**\n     * Cache for canvas width and height values\n     * @type {number}\n     * @private\n     */\n    this._width = 0;\n    this._height = 0;\n  }\n\n  static get CSS(){\n    return {\n      oxGroup: 'ox-group',\n      oyGroup: 'oy-group',\n    }\n  }\n\n  /**\n   * How much the original ratio of height to max-min is changed to fit new min & max points\n   * @return {number}\n   */\n  get kYScaled(){\n    return this.kY * this.oyScaling;\n  }\n\n  /**\n   * Prepares the SVG element\n   * @param {number} [width] - strict canvas width\n   * @param {number} [height] - strict canvas height\n   * @return {SVGElement}\n   */\n  renderCanvas({width, height} = {}){\n    this.canvas = Dom.make('svg');\n    this.oxGroup = Dom.make('g');\n    this.oyGroup = Dom.make('g');\n\n    this.oxGroup.setAttribute('class', Graph.CSS.oxGroup);\n    this.oyGroup.setAttribute('class', Graph.CSS.oyGroup);\n    this.oyGroup.setAttribute('vector-effect', 'non-scaling-stroke');\n    this.oxGroup.setAttribute('vector-effect', 'non-scaling-stroke');\n\n    if (!width){\n      this.computeInitialWidth();\n    } else {\n      this.width = this.initialWidth = width;\n    }\n\n    if (height){\n      this.height = height;\n    }\n\n    this.computeSteps();\n\n    this.oyGroup.appendChild(this.oxGroup);\n    this.canvas.appendChild(this.oyGroup);\n\n    return this.canvas;\n  }\n\n  /**\n   * Compute and set initial canvas width\n   */\n  computeInitialWidth(){\n    this.initialWidth = (this.state.daysCount - 1) * this.stepX;\n    this.width = this.initialWidth;\n  }\n\n  /**\n   * Return total (big) chart width\n   * @return {number}\n   */\n  get width(){\n    return this._width;\n  }\n\n  /**\n   * Set canvas width\n   * @param {number} val\n   */\n  set width(val){\n    this._width = val;\n    this.canvas.style.width = val + 'px';\n  }\n\n  /**\n   * Return chart height\n   * @return {number}\n   */\n  get height(){\n    return this._height;\n  }\n\n  /**\n   * Set canvas height\n   * @param {number} val\n   */\n  set height(val){\n    this._height = val;\n    this.canvas.style.height = val + 'px';\n  }\n\n  /**\n   * Calculates stepX by canvas width and total points count\n   */\n  computeSteps(){\n    this.stepX = this.width / (this.state.daysCount - 1);\n\n    /**\n     * All lines maximum value\n     */\n    const max = this.state.max;\n    const min = this.state.min;\n    const stepsAvailable = [5, 10, 25, 50, 100, 1000, 500, 10000, 5000, 100000, 1000000, 10000000];\n    let newStepYIndex = stepsAvailable.reverse().findIndex( (step) => {\n      let c = (max - min) > step;\n\n      return c;\n    }),\n    newStepY = stepsAvailable[newStepYIndex];\n\n    if (max / newStepY < 3 && newStepYIndex < stepsAvailable.length - 1){\n      newStepY = stepsAvailable[newStepYIndex + 1];\n    }\n\n    this.stepY = newStepY;\n  }\n\n  renderCharts(){\n    const type = this.state.getCommonChartsType();\n\n    switch (type){\n      case 'bar':\n        this.maxPoint = this.state.getMaximumAccumulatedByColumns(); // 20% for padding top\n        this.minPoint = this.state.min;\n        this.drawBarCharts();\n        break;\n      case 'area':\n        this.maxPoint = this.state.getMaximumAccumulatedByColumns(); // 20% for padding top\n        this.drawAreaCharts();\n        break;\n      default:\n      case 'line':\n        if (!this.state.isYScaled) {\n          this.maxPoint = this.state.max;\n          this.minPoint = this.state.min;\n\n          this.drawLineCharts();\n        } else {\n          this.drawScaledLineCharts();\n        }\n\n        break;\n    }\n  }\n\n  drawAreaCharts(){\n    let areas = this.state.linesAvailable.reverse().map( line => {\n      return new Area({\n        canvasHeight: this.height,\n        stepX: this.stepX,\n        key: line,\n        color: this.state.getLineColor(line)\n      });\n    });\n\n    const pointsCount = this.state.daysCount;\n    const stacks = this.state.getStacks();\n\n    this.state.linesAvailable.reverse().forEach( (line, index) => {\n      areas[index].moveTo(0, this.state.getLinePoints(line)[0], stacks[0]);\n    });\n\n    for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {\n      let prevValue = 0;\n\n      this.state.linesAvailable.reverse().forEach( (line, index) => {\n        let pointValue = this.state.getLinePoints(line)[pointIndex];\n\n        if (pointIndex === 0){\n          areas[index].stepTo(stacks[pointIndex], prevValue, true);\n        } else {\n          areas[index].stepTo(stacks[pointIndex], prevValue);\n        }\n\n        prevValue += pointValue;\n      });\n    }\n\n    areas.forEach(area => {\n      area.finish();\n      this.oxGroup.appendChild(area.getAll());\n      this.charts[area.key] = area;\n    });\n  }\n\n  drawBarCharts(){\n    const kY = this.maxPoint !== 0 ? this.height / this.maxPoint : 1;\n    let barmens = this.state.linesAvailable.reverse().map( line => {\n      return new Bar({\n        canvasHeight: this.height,\n        stepX: this.stepX,\n        kY,\n        key: line\n      });\n    });\n\n    const pointsCount = this.state.daysCount;\n    const stacks = this.state.getStacks();\n\n    for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {\n      let prevValue = 0;\n\n      this.state.linesAvailable.reverse().forEach( (line, index) => {\n        const color = this.state.getLineColor(line);\n\n\n\n        let pointValue = this.state.getLinePoints(line)[pointIndex];\n\n        // const editorLabelStyle = `line-height: 1em;\n        //     color: #fff;\n        //     display: inline-block;\n        //     font-size: 12px;\n        //     line-height: 1em;\n        //     background-color: ${color};\n        //     padding: 4px 9px;\n        //     border-radius: 30px;\n        //     margin: 4px 5px 4px 0;`;\n        // console.log(`%c${pointValue}`, editorLabelStyle);\n\n\n        barmens[index].add(pointValue, stacks[pointIndex], prevValue, color);\n        prevValue += pointValue;\n      });\n\n\n\n      // console.log('%o -> stack %o', pointIndex, stackValue);\n    }\n\n    barmens.forEach(barmen => {\n      this.oxGroup.appendChild(barmen.getAll());\n      this.charts[barmen.key] = barmen;\n    });\n  }\n\n  /**\n   * Return names of hidden charts\n   */\n  get hiddenCharts(){\n    return Object.entries(this.charts).filter(([name, chart]) => chart.isHidden).map(([name]) => name);\n  }\n\n  /**\n   * Return max visible point\n   * If line passed, check for that. Otherwise, return maximum between all\n   */\n  getMaxFromVisible(leftPointIndex = 0, pointsVisible = this.state.daysCount, line = undefined){\n    const type = this.state.getCommonChartsType();\n\n    switch (type) {\n      case 'bar':\n        return this.state.getMaximumAccumulatedByColumns(leftPointIndex, leftPointIndex + pointsVisible, this.hiddenCharts);\n        break;\n      default:\n      case 'line':\n        if (!line) {\n          return Math.max(...this.state.linesAvailable.filter(line => this.checkPathVisibility(line)).map(line => {\n            return this.state.getMaxForLineSliced(line, leftPointIndex, pointsVisible);\n          }));\n        }\n\n        return this.state.getMaxForLineSliced(line, leftPointIndex, pointsVisible, line);\n        break;\n    }\n  }\n\n  drawScaledLineCharts(){\n    this.state.linesAvailable.forEach( name => {\n      const lineMin = this.state.minForLine(name);\n      const lineMax = this.state.maxForLine(name);\n      const values = this.state.getLinePoints(name);\n\n      // console.log('[%o] min %o max %o', name, lineMin, lineMax);\n\n      let kY = this.height / (lineMax - lineMin);\n      let zeroShifting = lineMin * kY;\n\n      /**\n       * Create a Path instance\n       */\n      const path = new Path({\n        canvasHeight: this.height,\n        isScaled: this.state.isYScaled,\n        max: lineMax,\n        color: this.state.getLineColor(name),\n        zeroShifting,\n        kY,\n        stroke: this.strokeWidth,\n        stepX: this.stepX,\n      });\n\n      path.moveTo(0, values[0]);\n\n      values.forEach( (column, index )=> {\n        if (index === 0){\n          path.stepTo(column, true);\n        } else {\n          path.stepTo(column);\n        }\n      });\n\n      this.oxGroup.appendChild(path.render());\n\n      this.charts[name] = path;\n\n    });\n  }\n\n  /**\n   * Create a 'line' charts\n   */\n  drawLineCharts(){\n    this.state.linesAvailable.forEach( name => {\n      /**\n       * Array of chart Y values\n       */\n      const values = this.state.getLinePoints(name);\n\n      /**\n       * Color of drawing line\n       */\n      const color = this.state.getLineColor(name);\n\n      /**\n       * Point to from which we will start drawing\n       */\n      const leftPoint = values[0];\n\n      this.kY = this.height / (this.maxPoint - this.minPoint);\n      this.zeroShifting = this.minPoint * this.kY;\n\n      /**\n       * Create a Path instance\n       */\n      const path = new Path({\n        canvasHeight: this.height,\n        max: this.maxPoint,\n        min: this.minPoint,\n        color,\n        zeroShifting: this.zeroShifting,\n        kY: this.kY,\n        stroke: this.strokeWidth,\n        stepX: this.stepX,\n      });\n\n      path.moveTo(0, leftPoint);\n\n      values.forEach( (column, index )=> {\n        if (index === 0){\n          path.stepTo(column, true);\n        } else {\n          path.stepTo(column);\n        }\n      });\n\n      this.oxGroup.appendChild(path.render());\n\n      this.charts[name] = path;\n    });\n  }\n\n  scroll(newLeft){\n    this.oxGroup.style.transform = `matrix(${this.modules.chart.scaling},0,0,1,${newLeft},0)`;\n  }\n\n  /**\n   * Scale left legend\n   * @param {number} scaling\n   */\n  scaleLines(scaling){\n    this.oxGroup.style.transform = `scaleX(${scaling})`;\n    this.width = this.initialWidth * scaling;\n  }\n\n  get step(){\n    return this.stepX;\n  }\n\n  /**\n   * Scale path on OY\n   * @param {number} newMax - new max value\n   */\n  scaleToMaxPoint(newMax, newMin, line){\n    // console.log('newMax, newMin, line', newMax, newMin, line);\n    // newMax = Numbers.round(newMax);\n    // console.warn('min', newMin, Numbers.roundToMin(newMin, (newMax - newMin) / 5));\n\n\n    newMin = Numbers.roundToMin(newMin, (newMax - newMin) / 5);\n\n\n    let max, kY, zeroShifting;\n\n    if (!this.state.isYScaled){\n      max = this.maxPoint;\n      kY = this.kY;\n\n      // area and bars\n      if (!this.zeroShifting || !newMin){\n        this.oyScaling = max / newMax;\n        this.oyGroup.style.transform = `scaleY(${this.oyScaling})`;\n        return;\n      }\n\n      let newKY = this.height / (newMax - newMin);\n      let newZeroShifting = newMin * kY;\n      let shift = newZeroShifting - this.zeroShifting;\n\n      this.oyScaling = newKY / kY;\n      this.zeroShiftingScaling = shift !== 0 ? newZeroShifting / this.zeroShifting  : 1;\n      this.currentMinimum = newMin;\n\n      this.oyGroup.style.transform = `scaleY(${this.oyScaling}) translateY(${shift}px)`;\n\n    } else {\n      const chart = this.charts[line];\n      max = chart.max;\n      kY = chart.kY;\n      zeroShifting = chart.zeroShifting;\n\n\n      let newKY = this.height / (newMax - newMin);\n      let newZeroShifting = newMin * kY;\n      let shift = newZeroShifting - zeroShifting;\n\n      // need to store somewhere\n      let oyScaling = newKY / kY;\n      let zeroShiftingScaling = shift !== 0 ? newZeroShifting / zeroShifting  : 1;\n      chart.currentMinimum = newMin;\n\n      chart.path.style.transform = `scaleY(${oyScaling}) translateY(${shift}px)`;\n      // chart.path.setAttribute('transform', `scale(1 ${oyScaling}) translate(0, ${shift})`);\n    }\n  }\n\n  /**\n   * Change bars height and Y to fit hidden charts place\n   */\n  recalculatePointsHeight(useRecalculated = false){\n    if (this.type === 'bar'){\n      this.recalculateBars(useRecalculated);\n    } else if (this.type === 'area') {\n      this.recalculateArea(useRecalculated);\n    }\n  }\n\n  recalculateArea(useRecalculated = false){\n    const pointsCount = this.state.daysCount;\n    const stacks = this.state.getStacks();\n\n    let recalculated = this.state.recalculatedValues;\n\n    if (useRecalculated && recalculated) {\n      for (let i = 0, lenCached = recalculated.length; i < lenCached; i++) {\n        if (recalculated[i][1] === 0){\n          this.charts[recalculated[i][0]].move(recalculated[i][1], recalculated[i][2], recalculated[i][3], true);\n        } else {\n          this.charts[recalculated[i][0]].move(recalculated[i][1], recalculated[i][2], recalculated[i][3]);\n        }\n      }\n\n      this.state.clearRecalculatedValues();\n      return;\n    }\n\n    let lines = this.state.linesAvailable.filter(line => this.checkPathVisibility(line)).reverse();\n\n    for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {\n      let prevValue = 0;\n\n      let hiddenPointsValue = this.hiddenCharts.reduce( (val, line) => {\n        return val + this.state.getLinePoints(line)[pointIndex];\n      }, 0);\n\n      for (let i = 0, lenCached = lines.length; i < lenCached; i++) {\n        let newStack = stacks[pointIndex] - hiddenPointsValue;\n        let pointValue = this.state.getLinePoints(lines[i])[pointIndex];\n\n        this.state.saveRecalculatedValues([lines[i], pointIndex, newStack, prevValue]);\n\n        if (pointIndex === 0){\n          this.charts[lines[i]].move(pointIndex, newStack, prevValue, true);\n        } else {\n          this.charts[lines[i]].move(pointIndex, newStack, prevValue);\n        }\n\n        prevValue += pointValue;\n      }\n    }\n\n    Object.entries(this.charts).filter(([line, area]) => this.checkPathVisibility(line)).forEach(([line, area]) => {\n      area.update();\n    });\n  }\n\n  /**\n   * Changes bars heights to correspond hidden charts\n   * @param {boolean} useRecalculated - pass true to use saved value (minimap can use values from main Chart)\n   */\n  recalculateBars(useRecalculated = false){\n    const pointsCount = this.state.daysCount;\n    const stacks = this.state.getStacks();\n\n    let recalculated = this.state.recalculatedValues;\n\n    if (useRecalculated && recalculated) {\n      for (let i = 0, lenCached = recalculated.length; i < lenCached; i++) {\n        this.charts[recalculated[i][0]].move(recalculated[i][1], recalculated[i][2], recalculated[i][3]);\n      }\n\n      this.state.clearRecalculatedValues();\n      return;\n    }\n\n    let lines = this.state.linesAvailable.filter(line => this.checkPathVisibility(line)).reverse();\n\n    for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {\n      let prevValue = 0;\n\n      let hiddenPointsValue = this.hiddenCharts.reduce( (val, line) => {\n        return val + this.state.getLinePoints(line)[pointIndex];\n      }, 0);\n\n      for (let i = 0, lenCached = lines.length; i < lenCached; i++) {\n        let newStack = stacks[pointIndex] - hiddenPointsValue;\n        let pointValue = this.state.getLinePoints(lines[i])[pointIndex];\n\n\n        this.state.saveRecalculatedValues([lines[i], pointIndex, newStack, prevValue]);\n        this.charts[lines[i]].move(pointIndex, newStack, prevValue);\n\n        prevValue += pointValue;\n      }\n    }\n  }\n\n  checkPathVisibility(name){\n    return !this.charts[name].isHidden;\n  }\n\n  togglePathVisibility(name, status){\n    this.charts[name].toggleVisibility(status);\n  }\n}","import * as Dom from '../utils/dom.js';\nimport * as Event from '../utils/event.js';\nimport debounce from '../utils/debounce.js';\nimport Graph from './graph.js';\nimport log from '../utils/log.js';\n\n\n/**\n * Module for working with Chart Mini map\n * - Render UI\n * - Render graphs\n * - Scaling\n * - Scrolling\n */\nexport default class Minimap {\n  /**\n   * Telegraph\n   * @param modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      canvas: undefined,\n\n      leftZone: undefined,\n      leftZoneScaler: undefined,\n      rightZone: undefined,\n      rightZoneScaler: undefined,\n      centerZone: undefined\n    };\n\n    this.wrapperWidthCached = undefined;\n    this.viewportWidth = 100;\n    this.viewportWidthInitial = 100;\n    this.viewportOffsetLeft = 0;\n\n    /**\n     * Remember width on touch start\n     */\n    this.viewportWidthBeforeDrag = undefined;\n\n    /**\n     * Clicked pageX\n     */\n    this.moveStartX = undefined;\n\n    /**\n     * Clicked layerX\n     */\n    this.wrapperLeftCoord = undefined;\n\n    /**\n     * Indicator that viewport zone is dragged\n     */\n    this.viewportPressed = false;\n\n    /**\n     * Indicator that left scaler zone is dragged\n     */\n    this.leftScalerClicked = false;\n\n    /**\n     * Indicator that right scaler zone is dragged\n     */\n    this.rightScalerClicked = false;\n\n    /**\n     * Scale debounce\n     */\n    this.scaleDebounce = undefined;\n\n    /**\n     * Cache for zones size\n     */\n    this.leftZoneWidth = 0;\n    this.rightZoneWidth = 0;\n\n    this.prevX = 0;\n\n    this.graph = new Graph(this.modules, {\n      stroke: 1,\n      animate: true\n    });\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-minimap',\n      leftZone: 'tg-minimap__left',\n      leftZoneScaler: 'tg-minimap__left-scaler',\n      rightZone: 'tg-minimap__right',\n      rightZoneScaler: 'tg-minimap__right-scaler',\n      centerZone: 'tg-minimap__center',\n    }\n  }\n\n  /**\n   * Prepares minimap UI\n   * @return {Element}\n   */\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Minimap.CSS.wrapper);\n    this.nodes.leftZone = Dom.make('div', Minimap.CSS.leftZone);\n    this.nodes.centerZone = Dom.make('div', Minimap.CSS.centerZone);\n    this.nodes.rightZone = Dom.make('div', Minimap.CSS.rightZone);\n    this.nodes.leftZoneScaler = Dom.make('div', Minimap.CSS.leftZoneScaler);\n    this.nodes.rightZoneScaler = Dom.make('div', Minimap.CSS.rightZoneScaler);\n\n    this.nodes.leftZone.appendChild(this.nodes.leftZoneScaler);\n    this.nodes.rightZone.appendChild(this.nodes.rightZoneScaler);\n\n    this.nodes.wrapper.appendChild(this.nodes.leftZone);\n    this.nodes.wrapper.appendChild(this.nodes.centerZone);\n    this.nodes.wrapper.appendChild(this.nodes.rightZone);\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Fill UI with chart and set initial Position\n   */\n  renderMap(){\n    this.nodes.canvas = this.graph.renderCanvas({\n      width: this.nodes.wrapper.offsetWidth,\n      height: this.nodes.wrapper.offsetHeight\n    });\n\n    this.graph.renderCharts();\n\n    this.setInitialPosition();\n\n    this.nodes.wrapper.appendChild(this.nodes.canvas);\n  }\n\n  /**\n   * Return width of a mini map\n   * @return {number}\n   */\n  get wrapperWidth(){\n    return this.wrapperWidthCached || this.nodes.wrapper.offsetWidth;\n  }\n\n  /**\n   * Compute current minimap width\n   * @return {number}\n   */\n  get width(){\n    return this.wrapperWidth - this.leftZoneWidth - this.rightZoneWidth;\n  }\n\n  /**\n   * Left zone width setter\n   */\n  set leftWidth(val){\n    this.leftZoneWidth = val;\n    this.nodes.leftZone.style.width = val + 'px';\n    this.nodes.centerZone.style.left = val + 16 + 'px';\n  }\n\n  /**\n   * Right zone width setter\n   */\n  set rightWidth(val){\n    this.rightZoneWidth = val;\n    this.nodes.rightZone.style.width = val + 'px';\n  }\n\n  /**\n   * Set new with to the minimap's viewport\n   * @param {number} value\n   */\n  set width(value){\n    const scrollDistance = this.modules.chart.scrollDistance;\n\n    this.leftWidth = scrollDistance;\n    this.rightWidth = this.wrapperWidth - scrollDistance - value;\n\n    this.viewportWidth = value;\n    this.centerWidth = value;\n  }\n\n  set centerWidth(value){\n    this.nodes.centerZone.style.width = (value - 32) + 'px';\n  }\n\n  /**\n   * Initial width and offset\n   */\n  setInitialPosition(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n    this.wrapperWidthCached = rect.width;\n    this.wrapperLeftCoord = rect.left;\n\n    this.width = this.modules.chart.minimalMapWidth;\n\n    this.viewportWidthInitial = this.viewportWidthBeforeDrag = this.width;\n    this.viewportOffsetLeft = this.wrapperWidth - this.viewportWidthInitial;\n    this.moveViewport(this.viewportOffsetLeft);\n    this.syncScrollWithChart(this.viewportOffsetLeft);\n    this.modules.chart.fitToMax();\n  }\n\n  /**\n   * Current scroll value\n   * @return {number}\n   */\n  get scrolledValue(){\n    return this.leftZoneWidth;\n  }\n\n  /**\n   * Value of left zone width minimum\n   */\n  get leftZoneMinimumWidth(){\n    return 0;\n  }\n\n  /**\n   * Value of left zone width maximum\n   */\n  get leftZoneMaximumWidth(){\n    return this.wrapperWidth - this.viewportWidthInitial - this.rightZoneWidth;\n  }\n\n  /**\n   * Value of right zone width minimum\n   */\n  get rightZoneMinimumWidth(){\n    return this.viewportWidthInitial;\n  }\n\n  /**\n   * Value of right zone width maximum\n   */\n  get rightZoneMaximumWidth(){\n    return this.wrapperWidth - this.viewportWidthInitial - this.scrolledValue;\n  }\n\n  /**\n   * Moves viewport from left for passed value\n   * @param {string} offsetLeft\n   */\n  moveViewport(offsetLeft){\n    // log({offsetLeft})\n    const width = this.width;\n    const maxLeft = this.wrapperWidth - width;\n    const minLeft = this.leftZoneMinimumWidth;\n\n    let newLeft = this.viewportOffsetLeft + offsetLeft;\n\n    if (newLeft < minLeft){\n      newLeft = minLeft;\n    } else if (newLeft > maxLeft){\n      newLeft = maxLeft;\n    }\n    this.leftWidth = newLeft;\n    this.rightWidth = this.wrapperWidth - this.viewportWidthBeforeDrag - newLeft;\n  }\n\n  bindEvents(){\n    let supportsPassive = false;\n    try {\n      let opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n\n    this.nodes.wrapper.addEventListener('mousedown', (event) => {\n      this.viewportMousedown(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    document.body.addEventListener('mousemove', (event) => {\n      this.viewportMousemove(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    document.body.addEventListener('mouseup', (event) => {\n      this.viewportMouseup(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('touchstart', (event) => {\n      this.viewportMousedown(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('touchmove', (event) => {\n      this.viewportMousemove(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('touchend', (event) => {\n      this.viewportMouseup(event);\n    }, supportsPassive ? { passive: true } : false);\n  }\n\n  /**\n   * Viewport under finger\n   * @param {MouseEvent|TouchEvent} event\n   */\n  viewportMousedown(event){\n    const {target} = event;\n\n    // event.preventDefault();\n\n    const leftScalerClicked = !!target.closest(`.${Minimap.CSS.leftZoneScaler}`);\n    const rightScalerClicked = !!target.closest(`.${Minimap.CSS.rightZoneScaler}`);\n\n    this.viewportWidthBeforeDrag = this.width;\n    this.moveStartX = Event.getPageX(event);\n\n    if (leftScalerClicked || rightScalerClicked){\n      this.leftScalerClicked = leftScalerClicked;\n      this.rightScalerClicked = rightScalerClicked;\n      this.viewportPressed = false;\n      return;\n    }\n\n\n    this.viewportPressed = true;\n  }\n\n  /**\n   * Viewport dragged\n   * @param {MouseEvent} event\n   */\n  viewportMousemove(event){\n    if (this.viewportPressed){\n      this.viewportDragged(event);\n    } else if (this.leftScalerClicked){\n      this.scalerDragged(event, 'left');\n    } else if (this.rightScalerClicked){\n      this.scalerDragged(event, 'right');\n    }\n  }\n\n  viewportMouseup(){\n    if (this.viewportPressed){\n      this.finishSliding();\n    } else if (this.leftScalerClicked){\n      this.finishLeftScaling();\n    } else if (this.rightScalerClicked){\n      this.finishRightScaling();\n    }\n  }\n\n  finishSliding(){\n    this.viewportPressed = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n\n\n    // let start = null;\n    //\n    // // console.log('direction', direction);\n    //\n    // let step = (timestamp) => {\n    //   if (!start) start = timestamp;\n    //   var progress = timestamp - start;\n    //   let forTo = Math.min(progress / this.prevX, 500);\n    //\n    //   console.log('forTo', this.prevX, progress);\n    //\n    //   // console.log('progress', progress);\n    //   this.moveViewport(forTo * 5);\n    //   // element.style.transform = 'translateX(' + Math.min(progress / 10, 200) + 'px)';\n    //   if (progress < 100) {\n    //     window.requestAnimationFrame(step);\n    //   }\n    // }\n\n    // window.requestAnimationFrame(step);\n  }\n\n  finishLeftScaling(){\n    this.leftScalerClicked = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n  }\n\n  finishRightScaling(){\n    this.rightScalerClicked = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n  }\n\n  /**\n   * @param {MouseEvent} event\n   */\n  viewportDragged(event){\n    let delta = Event.getPageX(event) - this.moveStartX;\n\n    // let direction = this.prevX < delta ? 'right' : 'left';\n\n    let prevScrolledValue = this.scrolledValue;\n\n    // this.prevX = delta + 0;\n    this.moveViewport(delta);\n    // console.log('delta', delta);\n    // this.modules.chart.scrollByDelta((prevScrolledValue - delta) * this.modules.chart.width / this.wrapperWidth );\n\n    this.syncScrollWithChart();\n\n    if (this._ftmd){\n      clearTimeout(this._ftmd);\n    }\n\n    this._ftmd = setTimeout(() => {\n      this.modules.chart.fitToMax(true);\n    }, 50)\n\n  }\n\n  /**\n   * Sync scroll between minimap and chart\n   * @param {number} [newScroll] - pass scroll if you have\n   */\n  syncScrollWithChart(newScroll = null, fromScale = false){\n    // console.log('this.scrolledValue', this.scrolledValue);\n    /**\n     * How many percents of mini-map is scrolled\n     */\n    let scrolledValue = !isNaN(parseInt(newScroll)) ? newScroll : this.scrolledValue;\n    const minimapScrolledPortion = scrolledValue / this.wrapperWidth;\n    const chartScroll = minimapScrolledPortion * this.modules.chart.width;\n\n    this.modules.chart.scroll(chartScroll, fromScale);\n  }\n\n  /**\n   * Viewport side-scaler is moved\n   * @param {MouseEvent|TouchEvent} event\n   * @param {string} side  'left' or 'right'\n   */\n  scalerDragged(event, side){\n    let pageX = Event.getPageX(event);\n    let delta = pageX - this.moveStartX;\n\n    let direction = this.prevX < pageX ? 'right' : 'left';\n\n    if (!delta || this.prevX === pageX){\n      return;\n    }\n\n    this.prevX = pageX + 0;\n\n    let newScalerWidth;\n\n    if (side === 'left'){\n      delta = delta * -1;\n      newScalerWidth = this.viewportOffsetLeft - delta;\n\n      if (newScalerWidth > this.leftZoneMaximumWidth) {\n        return;\n      }\n\n      this.leftWidth = newScalerWidth;\n\n      this.centerWidth = (this.wrapperWidth - newScalerWidth - this.rightZoneWidth)\n\n    } else {\n      newScalerWidth = this.wrapperWidth - this.viewportOffsetLeft - (this.viewportWidthBeforeDrag + delta);\n\n      if (newScalerWidth > this.rightZoneMaximumWidth){\n        return;\n      }\n\n      this.rightWidth = newScalerWidth;\n      this.centerWidth = (this.wrapperWidth - newScalerWidth - this.leftZoneWidth)\n    }\n\n\n\n    const newViewportWidth = side === 'left' ?\n      this.wrapperWidth - newScalerWidth - this.rightZoneWidth :\n      this.wrapperWidth - this.leftZoneWidth - newScalerWidth;\n\n    const scaling = this.viewportWidthInitial / newViewportWidth * this.modules.chart.initialScale;\n\n    this.modules.chart.scale(scaling, direction);\n    this.syncScrollWithChart(side === 'left' ? newScalerWidth : this.leftZoneWidth, true);\n\n    if (this._ftmd){\n      clearTimeout(this._ftmd);\n    }\n\n    this._ftmd = setTimeout(() => {\n      this.modules.chart.fitToMax();\n    }, 20)\n  }\n\n  /**\n   * Toggle path visibility\n   * @param {string} name - graph name\n   */\n  togglePath(name, status){\n    this.graph.togglePathVisibility(name, status);\n\n    if (this.state.type === 'bar'){\n      this.graph.recalculatePointsHeight(true);\n      this.fitToMax();\n    } else if (this.state.type === 'area') {\n      this.graph.recalculatePointsHeight(true);\n    } else {\n      this.fitToMax();\n    }\n\n\n  }\n\n  /**\n   * Upscale or downscale graph to fit visible points\n   */\n  fitToMax(){\n    if (this.state.type !== 'area'){\n      if (!this.state.isYScaled){\n        this.graph.scaleToMaxPoint(this.graph.getMaxFromVisible());\n      } else {\n        this.state.linesAvailable.filter(line => this.modules.chart.notHiddenGraph(line)).forEach((line) => {\n          this.graph.scaleToMaxPoint(this.graph.getMaxFromVisible(line), undefined, line);\n        })\n      }\n    }\n  }\n}","import * as Dom from '../utils/dom.js';\nimport * as Numbers from '../utils/numbers';\n\nexport default class Tooltip {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper:  undefined,\n      title: undefined,\n      values: undefined\n    };\n\n    this._width = 0;\n    this._values = [];\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, title: string, values: string, value: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-tooltip',\n      showed: 'tg-tooltip--showed',\n      title: 'tg-tooltip__title',\n      values: 'tg-tooltip__values',\n      value: 'tg-tooltip__values-item',\n      valueTitle: 'tg-tooltip__values-item-title',\n    }\n  }\n\n  render(){\n    this.nodes.wrapper = Dom.make('div', Tooltip.CSS.wrapper);\n    this.nodes.title = Dom.make('div', Tooltip.CSS.title);\n    this.nodes.values = Dom.make('div', Tooltip.CSS.values);\n\n    this.nodes.wrapper.appendChild(this.nodes.title);\n    this.nodes.wrapper.appendChild(this.nodes.values);\n\n    return this.nodes.wrapper;\n  }\n\n  show(){\n    this.nodes.wrapper.classList.add(Tooltip.CSS.showed);\n  }\n\n  hide(){\n    this.nodes.wrapper.classList.remove(Tooltip.CSS.showed);\n  }\n\n  move(lineLeftCoord, values){\n    if (!this._width){\n      this._width = this.nodes.wrapper.offsetWidth;\n    }\n\n    let max = Math.max(...values.map(value => value.value));\n    let maxBottom = max * this.modules.chart.graph.kY - this.modules.chart.graph.zeroShifting;\n\n    let offsetLeft = -25;\n    let left = lineLeftCoord + offsetLeft;\n\n    if (maxBottom > 260) {\n      left = left - this._width;\n    }\n\n    if (left < this._width + 25){\n      left = lineLeftCoord + 25\n    }\n\n    if (left + this._width > this.modules.chart.viewportWidth){\n      left = left - this._width;\n    }\n\n    //\n    // if (left + this._width > this.modules.chart.viewportWidth){\n    //   left = this.modules.chart.viewportWidth - this._width - 30;\n    // }\n\n\n    // if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth / 1.3){\n    //   offsetLeft = -1.3 * tooltipWidth;\n    // } else if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth ){\n    //   offsetLeft = -0.8 * tooltipWidth;\n    // } else if (lineLeftCoord < 45){\n    //   offsetLeft = 20;\n    // }\n\n    this.nodes.wrapper.style.left = `${left}px`;\n  }\n\n  clear(){\n    this.nodes.title.textContent = '';\n    this.nodes.values.innerHTML = '';\n  }\n\n  /**\n   * Render values of current hovered points\n   * @param {{name: string, value: number}[]} values\n   */\n  set values(values){\n    this.clear();\n\n    const prevValues = this._values;\n\n    this._values = [];\n\n    if (this._setValuesDebounce){\n      clearTimeout(this._setValuesDebounce);\n    }\n\n    let summ = 0;\n\n    for (let i = 0, lenCached = values.length; i < lenCached; i++) {\n      summ += values[i].value;\n    }\n\n\n    if (values.length > 2){\n      this._setValuesDebounce = setTimeout(() => {\n        values.forEach( ({name, value}, index) => {\n          this.createItem(this.modules.state.names[name], this.modules.state.colors[name], value, prevValues[index], index, values)\n        });\n\n        if (this.modules.state.type === 'bar' && values.length > 1){\n          this.createItem('All', '#000', summ, null, values.length, values, true)\n        }\n      }, 150)\n\n    } else {\n        values.forEach( ({name, value}, index) => {\n          this.createItem(this.modules.state.names[name], this.modules.state.colors[name], value, prevValues[index], index, values)\n        });\n\n        if (this.modules.state.type === 'bar' && values.length > 1){\n          this.createItem('All', '#fff', null, values.length, values, true)\n        }\n    }\n\n  }\n\n  createItem(title, color, value, prevValue, index = 0, all, isAll= false){\n    const item = Dom.make('div', Tooltip.CSS.value);\n    const counter = Dom.make('b');\n\n    if (isAll){\n      item.classList.add('all');\n    }\n\n    if (this.modules.state.type === 'area'){\n      let total = all.reduce((acc, cur) => acc += cur.value, 0);\n      let percent = Math.ceil((value / total) * 100);\n      let percentEl = Dom.make('span', 'percents');\n\n      percentEl.textContent = percent + '%';\n\n      item.appendChild(percentEl)\n    }\n\n    let titleEl = Dom.make('span', Tooltip.CSS.valueTitle);\n\n    titleEl.textContent = title;\n\n    item.appendChild(titleEl);\n    item.appendChild(counter);\n\n    counter.style.color = color;\n\n    let valueBeautified = Numbers.addSpaces(value);\n\n    setTimeout(() => {\n      Dom.animateCounter(counter, valueBeautified, prevValue);\n    }, 50 * index);\n\n\n    this.nodes.values.appendChild(item);\n    this._values.push(valueBeautified);\n  }\n\n  set title(string){\n    this.nodes.title.innerHTML = string;\n  }\n\n  /**\n   * @param {Date} dt\n   */\n  set date(dt){\n    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    const week = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n    let month = dt.getMonth();\n    let year = dt.getFullYear();\n    let weekday = dt.getDay();\n    let day = dt.getDate();\n    let left = Dom.make('span', 'left');\n    let right = Dom.make('span');\n\n    right.textContent = months[month] + ' ' +year;\n\n\n    this.nodes.title.innerHTML = '';\n    this.nodes.title.appendChild(left);\n    this.nodes.title.appendChild(right);\n\n    let newDate = `${week[weekday]}, ${day}`;\n\n\n    Dom.animateCounter(left, `${week[weekday]}, ${day}`, this._prevDate, 'top' );\n    this._prevDate = newDate\n  }\n}","import * as Dom from \"../utils/dom\";\n\n/**\n * Line with current values pointers\n */\nexport default class Pointer {\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper: undefined,\n    };\n    this.pointers = {};\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, showed: string, pointer: string}}\n   * @constructor\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-pointer',\n      showed: 'tg-pointer--showed',\n      pointer: 'tg-pointer__pointer',\n      pointerHidden: 'tg-pointer__pointer--hidden'\n    }\n  }\n\n  render(){\n    this.nodes.wrapper = Dom.make('div', Pointer.CSS.wrapper);\n    return this.nodes.wrapper;\n  }\n\n  show(){\n    this.nodes.wrapper.classList.add(Pointer.CSS.showed);\n  }\n\n  hide(){\n    this.nodes.wrapper.classList.remove(Pointer.CSS.showed);\n  }\n\n  move(leftPx){\n    this.show();\n    this.nodes.wrapper.style.left = `${leftPx}px`;\n  }\n\n  toggleVisibility(name){\n    if (this.pointers[name]) {\n      this.pointers[name].classList.toggle(Pointer.CSS.pointerHidden)\n    }\n  }\n\n  /**\n   * Show circles\n   * @param {{name: string, value: number}[]} values\n   */\n  showValues(values){\n    if (!Object.keys(this.pointers).length){\n      values.forEach( ({name}) => {\n        const item = Dom.make('div', Pointer.CSS.pointer);\n\n        item.style.borderColor = this.modules.state.colors[name];\n        this.nodes.wrapper.appendChild(item);\n        this.pointers[name] = item;\n      })\n    }\n\n    /**\n     * @type {Graph}\n     */\n    const {graph} = this.modules.chart;\n\n    values.forEach( ({name, value}) => {\n      const item = this.pointers[name];\n      const currentZero = graph.currentMinimum;\n      const valueFromZero = value - currentZero;\n      const coord = valueFromZero * graph.kYScaled;\n\n      // item.style.bottom = `${coord}px`;\n      item.style.transform = `translateY(-${coord}px)`;\n    })\n\n  }\n}","import * as Dom from '../utils/dom.js';\nimport Graph from './graph.js';\nimport Tooltip from \"./tooltip\";\nimport Pointer from \"./pointer\";\nimport * as Event from '../utils/event.js';\n\nimport log from '../utils/log.js';\nimport * as Numbers from \"../utils/numbers\";\nimport Bar from \"./bar\";\n\n/**\n * Module for working with main Chart zone\n * - Render UI\n * - Render axes\n * - Render graphs\n * - Toggle lines visibility\n */\nexport default class Chart {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      viewport: undefined,\n      canvas: undefined,\n      cursorLine: undefined,\n      grid: undefined,\n      gridLines: [],\n      legend: undefined,\n      legendDates: [],\n      overlays: undefined,\n      overlayLeft: undefined,\n      overlayRight: undefined,\n\n    };\n\n    this.tooltip = new Tooltip(this.modules);\n    this.pointer = new Pointer(this.modules);\n    this.graph = new Graph(this.modules, {\n      stroke: 2\n    });\n\n    this.wrapperLeftCoord = undefined;\n    this.scaling = 1;\n    this.scrollValue = 0;\n\n\n\n    this.legendDateWidth = 40;\n    this.legendDateWidthMargins = 20 * 2;\n    this.legendDatesHidedTimes = 0;\n    this.legendDatesRecentlyHided = false;\n\n\n    /**\n     * Set will be store indexes of visible dates\n     * @type {Set<number>}\n     */\n    this.onscreenDates = new Set();\n    this.onscreenDatesElements = {}; // origin index -> element mapping\n    this._datesPerScreenInitial = undefined;\n    this._showEveryNDateInitial = undefined;\n\n    /**\n     * Any properties can be cached here\n     * @type {{}}\n     */\n    this.cache = {};\n\n    this._initialScale = undefined;\n    this._initialStep = undefined;\n    this._hoveredPointIndex = undefined;\n  }\n\n  get initialStep(){\n    if (!this._initialStep){\n      this._initialStep = this.width / (this.state.daysCount - 1);\n    }\n    return this._initialStep;\n  }\n\n  get minimalMapWidth(){\n    return 80;\n  }\n\n  get initialScale(){\n    return this._initialScale;\n  }\n\n  /**\n   * Get initial scaling corresponded with minimal minimap width\n   */\n  calculateInitialValues(){\n    /**\n     * Width of viewport when chart is not scaled\n     * @type {number}\n     */\n    const chartToViewportRatio = this.viewportWidth / this.width;\n    const originalWidth = this.viewportWidth * chartToViewportRatio;\n    const scaledViewportRatio = this.minimalMapWidth / originalWidth;\n\n    const originalScalingChange = this.scaling / scaledViewportRatio;\n\n    this.initialScale = originalScalingChange;\n\n    // log({scaling: this.scaling});\n  }\n\n  set initialScale(value){\n    this._initialScale = value;\n    this.scale(value);\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, viewport: string, cursorLine: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-chart',\n      viewport: 'tg-chart__viewport',\n      grid: 'tg-grid',\n      gridSection: 'tg-grid__section',\n      gridSectionHidden: 'tg-grid__section--hidden',\n      gridCounter: 'tg-grid__counter',\n      gridCounterHidden: 'tg-grid__counter--hidden',\n      gridCounterFirst: 'tg-grid__counter--first',\n      gridCounterSecond: 'tg-grid__counter--second',\n      dateHidden: 'tg-legend__date--hidden',\n      overlays: 'tg-chart__overlays',\n      overlayLeft: 'tg-chart__overlay-left',\n      overlayRight: 'tg-chart__overlay-right',\n    }\n  }\n\n  get stepX(){\n    return this.graph.stepX;\n  }\n\n  get stepY(){\n    return this.graph.stepY;\n  }\n\n  get maxPoint(){\n    return this.graph.maxPoint;\n  }\n\n  get height(){\n    return this.graph.height;\n  }\n\n  /**\n   * Total chart width\n   * @return {number}\n   */\n  get width(){\n    return this.graph.width;\n  }\n\n  /**\n   * Return current scroll distance\n   * @return {number}\n   */\n  get scrollDistance() {\n    return this.scrollValue * this.scaling;\n  }\n\n  /**\n   * Visible viewport width\n   * @return {number}\n   */\n  get viewportWidth(){\n    if (this.cache.viewportWidth){\n      return this.cache.viewportWidth;\n    }\n\n    this.cache.viewportWidth = this.nodes.wrapper.offsetWidth;\n    return this.cache.viewportWidth;\n  }\n\n  /**\n   * Visible viewport height\n   * @return {number}\n   */\n  get viewportHeight(){\n    if (this.cache.viewportHeight){\n      return this.cache.viewportHeight;\n    }\n\n    this.cache.viewportHeight = this.nodes.wrapper.offsetHeight;\n    return this.cache.viewportHeight;\n  }\n\n  /**\n   * Prepare UI\n   * @return {Element}\n   */\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Chart.CSS.wrapper);\n    this.nodes.viewport = Dom.make('div', Chart.CSS.viewport);\n    this.nodes.cursorLine = this.pointer.render();\n\n    this.nodes.wrapper.appendChild(this.nodes.viewport);\n    this.nodes.wrapper.appendChild(this.nodes.cursorLine);\n    this.nodes.wrapper.appendChild(this.tooltip.render());\n\n    this.nodes.wrapper.classList.add(Chart.CSS.wrapper + '--' + this.state.type);\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Renders charts\n   */\n  renderCharts(){\n    this.calculateWrapperCoords();\n\n    /**\n     * @todo pass height through the initial settings\n     */\n    this.nodes.canvas = this.graph.renderCanvas({\n      height: 350\n    });\n    this.nodes.viewport.appendChild(this.nodes.canvas);\n\n    /**\n     * Get initial scale\n     */\n    this.calculateInitialValues();\n\n\n\n    this.graph.renderCharts();\n    this.renderGrid();\n    this.renderLegend();\n    this.renderOverlays();\n  }\n\n  createLine(){\n    const line = Dom.make('div', Chart.CSS.gridSection);\n    this.nodes.grid.appendChild(line);\n    this.nodes.gridLines.push(line);\n\n    return line;\n  }\n\n  getLegendStep(max, min, stepsCount, kY, kYRatio){\n    let diffSize = max - min;\n    let step = diffSize / stepsCount;\n    let decimals = Math.log10(diffSize) >> 0;\n    let rounding = Math.pow(10, decimals) / 2;\n    // console.log('step', step);\n\n    step = Math.ceil(step / rounding) * rounding;\n\n    let possibleHeight = step * stepsCount * kY;\n\n    if (possibleHeight > this.height){\n      step = step / (possibleHeight / this.height >> 0);\n    }\n\n    return step;\n  }\n\n  getLegendCounter(value, name, isSecond){\n    let counter = Dom.make('span', Chart.CSS.gridCounter);\n    counter.textContent = Numbers.beautify(Math.round(value));\n\n    counter.dataset.name = name;\n\n    if (isSecond){\n      counter.classList.add(Chart.CSS.gridCounterSecond);\n    } else {\n      counter.classList.add(Chart.CSS.gridCounterFirst);\n    }\n\n    return counter;\n  }\n\n  /**\n   * Render or updates a grid\n   */\n  renderGrid(){\n    if (!this.nodes.grid) {\n      this.nodes.grid = Dom.make('div', Chart.CSS.grid);\n      this.nodes.gridLines = [];\n      Dom.insertBefore(this.nodes.canvas, this.nodes.grid);\n    }\n\n    let height = this.height;\n    let max = this.getMaxVisiblePoint();\n    let min = !this.state.isYScaled ? this.graph.currentMinimum || 0 : this.graph.charts['y0'].currentMinimum;\n    let kY = height / (max - min);\n    let linesCount = 5;\n    let stepY = this.getLegendStep(max, min, linesCount, kY);\n\n    let stepYSecond, kYSecond, maxSecond, minSecond;\n\n    if (this.state.isYScaled){\n      maxSecond = this.getMaxVisiblePoint('y1');\n      minSecond = this.getMinVisiblePoint('y1');\n\n      kYSecond = height / (maxSecond - minSecond);\n      let kYRatio = kY / kYSecond;\n\n      stepYSecond = this.getLegendStep(maxSecond, minSecond, linesCount, kYSecond, kYRatio);\n    }\n\n    if (this.state.type === 'area'){\n      stepY = 25;\n      linesCount = 5;\n      max = 100;\n      kY = height / max;\n    }\n\n    if (this.nodes.gridLines.length){\n      this.nodes.gridLines.forEach( line => {\n        line.classList.add(Chart.CSS.gridSectionHidden);\n      })\n    }\n\n    for (let j = 0; j <= linesCount; j++) {\n      let y = j * stepY;\n      let line;\n\n      if (this.nodes.gridLines.length && this.nodes.gridLines[j]){\n        line = this.nodes.gridLines[j];\n      } else {\n        line = this.createLine();\n      }\n\n      if (j === 0){\n        line.classList.add('no-animation');\n      }\n\n      let bottom = y * kY;\n\n      if (bottom > this.height){\n        continue;\n      }\n\n      line.classList.remove(Chart.CSS.gridSectionHidden);\n      line.style.bottom = `${y * kY}px`;\n\n      line.innerHTML = '';\n\n\n\n      let counter = this.getLegendCounter(y + min, 'y0');\n      line.appendChild(counter);\n\n      if (stepYSecond){\n        counter.style.color = this.state.getLineColor('y0');\n        let kYRatio = kY / kYSecond;\n        let counter2 = this.getLegendCounter((j * stepYSecond + minSecond), 'y1', true);\n        counter2.style.color = this.state.getLineColor('y1');\n        line.appendChild(counter2);\n      }\n    }\n\n    if (this.state.isYScaled){\n      this.toggleGridLabelsForChart();\n    }\n  }\n\n  /**\n   * Check if date under passed index should be visible\n   * @param {number} originalIndex - index in this.state.dates\n   * @return {boolean}\n   */\n  checkDateShouldBeHidden(originalIndex){\n    let skippedCount = Math.round(((this.onscreenPointsCount / this.datesPerScreen ) - this._showEveryNDateInitial) / this._showEveryNDateInitial);\n    let checks = [];\n\n    for (let i = 1; i < skippedCount + 1; i++){\n      let idxToCheck = originalIndex + i * this._showEveryNDateInitial;\n      let check = idxToCheck % (this._showEveryNDateInitial * 2 * i) === 0;\n      checks.push(check)\n    }\n\n    return checks.some(check => !!check);\n  }\n\n  moveDate(originalIndex){\n    let dateEl = this.onscreenDatesElements[originalIndex];\n    let centering = 'translateX(-50%)';\n    let newX = originalIndex * this.stepScaled + this.scrollValue;\n\n    dateEl.style.transform = `translateX(${ newX }px)` + centering;\n\n    if (this.checkDateShouldBeHidden(originalIndex)){\n      dateEl.classList.add('hided');\n    } else {\n      dateEl.classList.remove('hided');\n    }\n  }\n\n\n  pushDate(date, originIndex, visibleIndex){\n    if (this.checkDateShouldBeHidden(originIndex)){\n      return;\n    }\n\n    const dt = new Date(date);\n    const dateEl = Dom.make('time');\n    dateEl.textContent = dt.toLocaleDateString('en-US', {\n      day: 'numeric',\n      month: 'short'\n    });\n\n    // dateEl.textContent = originIndex;\n\n    this.nodes.legend.appendChild(dateEl);\n    this.nodes.legendDates.push(dateEl);\n    this.onscreenDates.add(originIndex);\n    this.onscreenDatesElements[originIndex] = dateEl;\n    this.moveDate(originIndex);\n  }\n\n  get onscreenPointsCount(){\n    return Math.floor(this.viewportWidth / this.stepScaled);\n  }\n\n  /**\n   * Left visible point\n   * @return {number}\n   */\n  get leftPointIndex(){\n    return parseInt(Math.floor(this.scrollValue * -1/ this.stepX / this.scaling));\n  }\n\n  /**\n   * Right visible point\n   * @return {number}\n   */\n  get rightPointIndex(){\n    return this.leftPointIndex + this.onscreenPointsCount;\n  }\n\n  get datesPerScreen(){\n    if (!this._datesPerScreenInitial){\n      this._datesPerScreenInitial = Math.floor(this.viewportWidth / (this.legendDateWidth + this.legendDateWidthMargins));\n    }\n    return this._datesPerScreenInitial;\n  }\n\n  get stepScaled(){\n    return this.stepX * this.scaling\n  }\n\n  addOnscreenDates(){\n    /**\n     * Get slice of timestamps that currently visible on the screen\n     */\n    let datesOnScreenSlice = this.state.dates.slice(this.leftPointIndex, this.rightPointIndex + 2);\n    let datesOnScreenIndexes = new Set();\n\n    if (!this._showEveryNDateInitial){\n      let pointsOnScreen = this.rightPointIndex - this.leftPointIndex;\n      this._showEveryNDateInitial = Math.ceil(pointsOnScreen / this.datesPerScreen);\n    }\n\n    let visibleIndex = 0;\n\n    datesOnScreenSlice.forEach((date, index) => {\n      const originIndex = this.leftPointIndex + index;\n\n\n      /**\n       * Skip dates that can not be fit event on maximum zoom\n       */\n      if (originIndex % this._showEveryNDateInitial !== 0){\n        return;\n      }\n\n      /**\n       * Store index of added date to check if it out of screen\n       */\n      datesOnScreenIndexes.add(originIndex);\n\n      /**\n       * If point already showed, move it\n       */\n      if (this.onscreenDates.has(originIndex)){\n        this.moveDate(originIndex);\n        visibleIndex++;\n        return\n      }\n\n      /**\n       * Add new date to its position computed by original index * step scaled\n       */\n      this.pushDate(date, originIndex, visibleIndex);\n      visibleIndex++;\n    });\n\n    /**\n     * Remove dates that are out of screen\n     */\n    this.onscreenDates.forEach((originalIndex) => {\n      if (!datesOnScreenIndexes.has(originalIndex)) {\n        this.removeDate(originalIndex);\n      }\n    });\n  }\n\n  removeDate(originalIndex){\n    if (!this.onscreenDatesElements[originalIndex]){\n      return;\n    }\n\n    this.onscreenDates[originalIndex] = null;\n    this.onscreenDates.delete(originalIndex);\n    this.onscreenDatesElements[originalIndex].remove();\n    this.onscreenDatesElements[originalIndex] = null;\n  }\n\n  /**\n   * Renders a legend with dates\n   * @param {number[]} dates\n   */\n  renderLegend(){\n    this.nodes.legend = Dom.make('footer');\n\n    // this.addOnscreenDates();\n\n    Dom.insertAfter(this.nodes.canvas, this.nodes.legend);\n  }\n\n  /**\n   * Perform scroll\n   * @param position\n   */\n  scroll(position, fromScale){\n    this.scrollValue = position * -1;\n    this.graph.scroll(this.scrollValue);\n    this.tooltip.hide();\n    this.pointer.hide();\n    this.hideBarHighlighting();\n    this.addOnscreenDates();\n\n    if (this._sd){\n      clearTimeout(this._sd);\n    }\n\n    this._sd = setTimeout(()=>{\n      this.modules.header.setPeriod(this.state.dates[this.leftPointIndex], this.state.dates[this.rightPointIndex]);\n    }, 50)\n  }\n\n  /**\n   * Perform scaling\n   * @param {number} scaling\n   */\n  scale(scaling, direction){\n    this.graph.scaleLines(scaling, direction);\n\n    this.scaling = scaling;\n  }\n\n  /**\n   * Left visible point\n   * @return {number}\n   */\n  get leftPointIndex(){\n    return Math.round(this.scrollValue * -1/ this.graph.step / this.scaling);\n  }\n\n  /**\n   * Filter to skip hidden line\n   * @param {string} line - name of the graph\n   * @return {boolean}\n   */\n  notHiddenGraph(line){\n    return this.graph.checkPathVisibility(line);\n  }\n\n  get pointsVisible(){\n    const stepX = this.graph.step;\n    return Math.round(this.viewportWidth / stepX / this.scaling);\n  }\n\n  /**\n   * Return max visible point\n   * If line passed, check for that. Otherwise, return maximum between all\n   */\n  getMaxVisiblePoint(line = undefined){\n    return this.graph.getMaxFromVisible(this.leftPointIndex, this.pointsVisible, line);\n  }\n\n  /**\n   * Return min visible point\n   * If line passed, check for that. Otherwise, return maximum between all\n   */\n  getMinVisiblePoint(line = undefined){\n    if (!line){\n      return Math.min(...this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map(line => {\n        return this.state.getMinForLineSliced(line, this.leftPointIndex, this.pointsVisible);\n      }));\n    }\n\n    return this.state.getMinForLineSliced(line, this.leftPointIndex, this.pointsVisible);\n  }\n\n  /**\n   * Upscale or downscale graph to fit visible points\n   */\n  fitToMax(){\n    if (this.state.type !== 'area'){\n      if (!this.state.isYScaled){\n        this.graph.scaleToMaxPoint(this.getMaxVisiblePoint(), this.getMinVisiblePoint());\n      } else {\n        this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).forEach((line) => {\n          this.graph.scaleToMaxPoint(this.getMaxVisiblePoint(line), this.getMinVisiblePoint(line), line);\n        })\n      }\n    }\n\n    /**\n     * Rerender grid if it was rendered before\n     */\n    if (this.nodes.grid){\n\n      if (this._gd){\n        clearTimeout(this._gd);\n      }\n\n      this._gd = setTimeout(() => {\n        this.renderGrid();\n      }, 15)\n    }\n  }\n\n  /**\n   * Store wrapper rectangle data\n   */\n  calculateWrapperCoords(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n\n    this.wrapperLeftCoord = rect.left;\n  }\n\n  bindEvents(){\n    let supportsPassive = false;\n    try {\n      let opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    this.nodes.wrapper.addEventListener('mousemove', (event) => {\n      this.mouseMove(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('mouseleave', (event) => {\n      this.mouseLeave(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('touchmove', (event) => {\n      this.mouseMove(event);\n    }, supportsPassive ? { passive: true } : false);\n\n    this.nodes.wrapper.addEventListener('touchcancel', (event) => {\n      this.mouseLeave(event);\n    }, supportsPassive ? { passive: true } : false);\n  }\n\n  /**\n   * Shows line with Tooltip\n   * @param {MouseEvent|TouchEvent} event\n   */\n  mouseMove(event){\n    let x = Event.getPageX(event);\n    let viewportX = x - this.wrapperLeftCoord;\n\n    let stepXWithScale = this.graph.stepX * this.scaling;\n    let scrollOffset = this.scrollValue % stepXWithScale;\n    let pointIndex = Math.round(viewportX / this.graph.stepX / this.scaling);\n    let hoveredPointIndex = pointIndex + this.leftPointIndex;\n    // let firstStepOffset = this.graph.stepX - Math.abs(scrollOffset);\n\n    /**\n     * Prevent recalculations on mousemove with the same point\n     */\n    if (hoveredPointIndex === this._hoveredPointIndex){\n      return;\n    }\n\n    this._hoveredPointIndex = hoveredPointIndex;\n\n    if (Math.abs(scrollOffset) > (stepXWithScale / 2) ){\n      pointIndex = pointIndex + 1;\n    }\n\n    let newLeft = pointIndex * stepXWithScale + scrollOffset;\n\n    // console.log('scroll offset %o | step %o (%o)| index %o | x %o | drawn at %o | first step offset %o | left index %o ', scrollOffset, this.graph.stepX, stepXWithScale, pointIndex, viewportX, newLeft, firstStepOffset, this.leftPointIndex);\n\n     if (newLeft < this.stepScaled * 2){\n       // let old = this.scrollValue;\n       // let newScroll = (this.scrollValue + 20) * -1;\n\n       //scroll\n       //\n       // this.modules.minimap.moveViewport(-1 * (old*-1 - newScroll));\n       // this.scroll(newScroll);\n     }\n\n    this.tooltip.show();\n\n    if (this.state.type === 'bar'){\n      this.highlightBar(pointIndex -1, scrollOffset);\n    } else {\n      this.pointer.move(newLeft);\n    }\n\n    const values = this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map( line => {\n      return {\n        name: line,\n        value: this.state.getLinePoints(line)[hoveredPointIndex]\n      }\n    });\n\n    /**\n     * Show circles\n     */\n    this.pointer.showValues(values);\n\n    const date = this.state.dates[hoveredPointIndex];\n\n    /**\n     * Skip bounding empty positions\n     */\n    if (!date){\n      return;\n    }\n\n    this.tooltip.values = values;\n    this.tooltip.move(newLeft, values);\n    this.tooltip.date = new Date(date);\n  }\n\n  mouseLeave(){\n    this.tooltip.hide();\n    this.pointer.hide();\n    this.hideOverlays();\n  }\n\n  /**\n   * Toggle path visibility\n   * @param {string} name - graph name\n   */\n  togglePath(name, status){\n    this.graph.togglePathVisibility(name, status);\n    this.pointer.toggleVisibility(name);\n\n    if (this.state.type === 'bar'){\n      this.graph.recalculatePointsHeight();\n      this.fitToMax();\n    } else if (this.state.type === 'area') {\n      this.graph.recalculatePointsHeight();\n    } else {\n      this.fitToMax();\n    }\n  }\n\n  toggleGridLabelsForChart(){\n    this.state.linesAvailable.forEach(line => {\n      this.nodes.grid.querySelectorAll(`[data-name=\"${line}\"]`).forEach( el => {\n        el.classList.toggle(Chart.CSS.gridCounterHidden, !this.graph.checkPathVisibility(line))\n      });\n    });\n  }\n\n  highlightBar(index, scrollOffset){\n    this.nodes.overlays.style.opacity = '1';\n    this.nodes.overlayLeft.setAttribute('width', index * this.stepScaled + scrollOffset);\n    this.nodes.overlayRight.setAttribute('x', index * this.stepScaled + this.stepScaled + scrollOffset );\n    this.nodes.overlayRight.setAttribute('width', (this.onscreenPointsCount - index) * this.stepScaled - scrollOffset );\n  }\n\n  hideBarHighlighting(){\n    this.nodes.overlays.style.opacity = '0';\n  }\n\n  renderOverlays(){\n    this.nodes.overlays = Dom.make('g');\n    this.nodes.overlays.setAttribute('class', Chart.CSS.overlays);\n\n\n    this.nodes.overlayLeft = Dom.make('rect');\n    this.nodes.overlayLeft.setAttribute('class', Chart.CSS.overlayLeft);\n    this.nodes.overlayRight = Dom.make('rect');\n    this.nodes.overlayRight.setAttribute('class', Chart.CSS.overlayRight);\n\n    let defaultWidth = 0;\n\n    this.nodes.overlayLeft.setAttribute('x', 0);\n    this.nodes.overlayRight.setAttribute('x', this.viewportWidth - defaultWidth);\n    this.nodes.overlayLeft.setAttribute('y', 0);\n    this.nodes.overlayRight.setAttribute('y', 0);\n    this.nodes.overlayLeft.setAttribute('width', defaultWidth);\n    this.nodes.overlayRight.setAttribute('width', defaultWidth);\n    this.nodes.overlayLeft.setAttribute('height', this.viewportHeight);\n    this.nodes.overlayRight.setAttribute('height', this.viewportHeight);\n\n    this.nodes.overlays.appendChild(this.nodes.overlayLeft);\n    this.nodes.overlays.appendChild(this.nodes.overlayRight);\n    this.graph.canvas.appendChild(this.nodes.overlays);\n  }\n\n  hideOverlays(){\n    this.nodes.overlays.style.opacity = 0;\n  }\n\n}","import * as Dom from '../utils/dom.js';\n\nexport default class Legend {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper: undefined,\n    };\n\n    this.buttons = {};\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-legend',\n      item: 'tg-legend__item',\n      itemWobble: 'tg-legend__item--wobble',\n      itemSelected: 'tg-legend__item--selected',\n      itemEnabled: 'tg-legend__item--enabled',\n      checkbox: 'tg-legend__checkbox',\n    }\n  }\n\n  /**\n   * Show graphs togglers\n   * @return {Element}\n   */\n  render(){\n    this.nodes.wrapper = Dom.make('div', Legend.CSS.wrapper);\n\n    /**\n     * Object with names -> array with names\n     */\n    const namesArray = Object.entries(this.modules.state.names).map(([name, title]) => {\n      return {name, title}\n    });\n\n    namesArray.forEach(({name, title}) => {\n      let item = Dom.make('div', [Legend.CSS.item, Legend.CSS.itemEnabled]),\n        checkbox = Dom.make('span', Legend.CSS.checkbox);\n\n      item.style.borderColor = this.modules.state.colors[name];\n      item.style.backgroundColor = this.modules.state.colors[name];\n\n      item.appendChild(checkbox);\n      item.appendChild(document.createTextNode(title));\n\n      this.buttons[name] = item;\n\n      this._clickPrevented = false;\n\n      item.addEventListener('click', () => {\n        console.log('this._clickPrevented', this._clickPrevented);\n        if (!this._clickPrevented){\n          this.itemClicked(name);\n        }\n      });\n\n      item.addEventListener('mousedown', () => {\n        this.mousedown(name);\n      });\n\n      item.addEventListener('touchstart', () => {\n        this.mousedown(name);\n      });\n\n      item.addEventListener('mouseup', () => {\n        this.mouseup(name);\n      });\n\n      item.addEventListener('touchend', () => {\n        this.mouseup(name);\n      });\n\n      this.nodes.wrapper.appendChild(item);\n    });\n    return this.nodes.wrapper;\n  }\n\n  mousedown(name){\n    this._timer = setTimeout(() => {\n      this._clickPrevented = true;\n\n      console.log('this._clickPrevented', this._clickPrevented);\n      this.uncheckAllExceptPassed(name);\n    }, 500);\n  }\n\n  uncheckAllExceptPassed(exceptName) {\n    Object.entries(this.buttons).forEach(([name, el], index) => {\n        if (name !== exceptName){\n          this.buttons[name].classList.remove(Legend.CSS.itemEnabled);\n          this.buttons[name].style.backgroundColor = 'transparent';\n          this.buttons[name].style.color = this.modules.state.colors[name];\n\n          this.modules.chart.togglePath(name, true);\n          this.modules.minimap.togglePath(name, true);\n        } else {\n          this.buttons[name].classList.add(Legend.CSS.itemEnabled);\n          this.buttons[name].style.backgroundColor = this.modules.state.colors[name];\n          this.buttons[name].style.color = '#fff';\n\n          this.buttons[name].classList.add(Legend.CSS.itemSelected);\n          setTimeout(() => {\n            this.buttons[name].classList.remove(Legend.CSS.itemSelected);\n          }, 300);\n\n          this.modules.chart.togglePath(name, false);\n          this.modules.minimap.togglePath(name, false);\n        }\n    })\n\n  }\n\n\n  mouseup(name){\n    if (!this._timer){\n      return;\n    }\n\n    setTimeout(() => {\n      this._clickPrevented = false;\n      console.log('1this._clickPrevented', this._clickPrevented);\n    }, 400)\n\n    clearTimeout(this._timer);\n  }\n\n\n  /**\n   * Click handler for togglers\n   * @param {string} name - graph name\n   */\n  itemClicked(name){\n    let isLast = this.modules.state.linesAvailable.filter(line => this.modules.chart.graph.checkPathVisibility(line)).length === 1;\n\n    if (!this.buttons[name].classList.contains(Legend.CSS.itemEnabled)){\n      this.buttons[name].classList.add(Legend.CSS.itemEnabled);\n      this.buttons[name].style.backgroundColor = this.modules.state.colors[name];\n      this.buttons[name].style.color = '#fff';\n\n      this.buttons[name].classList.add(Legend.CSS.itemSelected);\n      setTimeout(() => {\n        this.buttons[name].classList.remove(Legend.CSS.itemSelected);\n      }, 300);\n    } else {\n      if (isLast){\n        this.buttons[name].classList.add(Legend.CSS.itemWobble);\n        setTimeout(() => {\n          this.buttons[name].classList.remove(Legend.CSS.itemWobble);\n        }, 300);\n\n        return;\n      }\n\n      this.buttons[name].classList.remove(Legend.CSS.itemEnabled);\n      this.buttons[name].style.backgroundColor = 'transparent';\n      this.buttons[name].style.color = this.modules.state.colors[name];\n    }\n\n    this.modules.chart.togglePath(name);\n    this.modules.minimap.togglePath(name);\n  }\n\n  toggle(name){\n\n  }\n}\n","import * as Dom from \"../utils/dom\";\n\nexport default class Header {\n  constructor(){\n    this.nodes = {\n      wrapper: undefined,\n      title: undefined,\n      dates: undefined,\n    };\n\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-header',\n      title: 'tg-header__title',\n      dates: 'tg-header__dates',\n    }\n  }\n\n  render(){\n    this.nodes.wrapper = Dom.make('div', Header.CSS.wrapper);\n    this.nodes.title = Dom.make('div', Header.CSS.title);\n    this.nodes.dates = Dom.make('div', Header.CSS.dates);\n\n    this.nodes.title.textContent = 'Messages';\n\n    this.nodes.wrapper.appendChild(this.nodes.title);\n    this.nodes.wrapper.appendChild(this.nodes.dates);\n\n    return this.nodes.wrapper\n  }\n\n  setPeriod(leftDateTimestamp, rightDateTimestamp){\n    this._sd = setTimeout(() => {\n      let leftDate = (new Date(leftDateTimestamp)).toLocaleDateString('en-US', {\n        day: 'numeric',\n        month: 'short',\n        year: 'numeric'\n      });\n      let rightDate = (new Date(rightDateTimestamp)).toLocaleDateString('en-US', {\n        day: 'numeric',\n        month: 'short',\n        year: 'numeric'\n      });\n\n      this.nodes.dates.innerHTML = `${leftDate} - ${rightDate}`;\n\n    }, 20)\n  }\n}","import State from './modules/state';\nimport Minimap from './modules/minimap.js';\nimport Chart from './modules/chart.js';\nimport Legend from './modules/legend.js';\nimport Header from './modules/header.js';\n\n/**\n * @typedef {object} ChartData\n */\n\nexport default class Telegraph {\n  /**\n   * Main entry constructor\n   * @param {string} holderId - where to append a Chart\n   * @param {string} data - chart data in csv format\n   * @param {string} type - graph type. Available types: 'line', 'area', 'bar'\n   * @param {string[]} colors - colors list for each line\n   * @param {string[]} titles - titles list for each line\n   */\n  constructor({holderId, data, colors, titles, type}){\n    this.holder = document.getElementById(holderId);\n\n    /**\n     * Module that stores all main app state values\n     */\n    this.state = new State(data, colors, titles, type);\n\n    /**\n     * Module for mini map\n     */\n    this.minimap = new Minimap(this);\n\n    /**\n     * Working with main chart zone\n     */\n    this.chart = new Chart(this);\n\n    /**\n     * Working with legend items\n     */\n    this.legend = new Legend(this);\n\n    /**\n     * Header module\n     */\n    this.header = new Header(this);\n\n    /**\n     * Create base UI elements\n     */\n    this.prepareUi();\n\n    /**\n     * Render chart and mini map\n     */\n    this.chart.renderCharts();\n    this.minimap.renderMap();\n\n    // console.timeEnd('telegraph');\n  }\n\n  /**\n   * CSS classes map\n   * @return {{nightModeEnabled: string}}\n   */\n  static get CSS(){\n    return {\n      nightModeEnabled : 'tg--night-mode'\n    }\n  }\n\n  /**\n   * Create base app UI\n   */\n  prepareUi(){\n    this.holder.appendChild(this.header.render());\n    this.holder.appendChild(this.chart.renderUi());\n    this.holder.appendChild(this.minimap.renderUi());\n    this.holder.appendChild(this.legend.render());\n  }\n\n  /**\n   * @public\n   * Toggles night mode\n   */\n  toggleNightMode(){\n    this.holder.classList.toggle(Telegraph.CSS.nightModeEnabled);\n  }\n}"],"sourceRoot":""}